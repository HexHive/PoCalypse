<?x    }
      }
      ml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE NewsML PUBLIC "urn:news-lRiptc.org:20M0100v1.0:1x" "dt0.dtd" [
  <!ENTITY % nitf SYSTEM "//@6'ce)----------------------ddddddddddddddddddd.dtd">
<!ENTITY % brandDitf SYSTEM "//@6'cedddddddddguddddddddddddRaddddddddddddddddddddddddddddddddddddddd.dtd">
<!ENTITY % branUDRtf SYSTEM "//@6'dddddddddddddddddDdddddd.dtd">
<!ENTITY % brandDTD SYSTEM "">
%u  <!ENTITY % nitf SYSTEM "//@6'c--------------------ddduddddddddddddddddd;&ddddddddddddddddddddddddddddddddduddddddddddddddddddddddddddddRadddddddddddddddddDdddddd.dtd">
<!ENTITY % T ">
%uOdateDTD;
%brandDTD;
     ;"dateDTD;
%bpandDTD;
     ;"/>
    ( </xul:ement>
      <s:element name="GetGeoIPContextResponse">
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="0" maxOccurs="1" name="GetGeoIPContextResult" type="tns:GeoIP"/>
          </s:sequence>
        </s:complexType>
      </s:element>
      <s:complexType name="GeoIP">
        <s:sequence>
          <s:element minOccurs="1" maxOccurs="1" name="ReturnCode" type="s:int"/>
          <s:element minOccurs="0" maxOccurs="1" name="IP" type="s:string"/>
          <s:element minOccurs="0" maxOccurs="1" name="ReturnCodeDetails" type="s:string"/>
          <s:element minOccurs="0" maxOccurs="1" name="CountryName" type="s:string"/>
          <s:element minOccurs="0" maxOccurs="1" name="CountryCode" type="s:string"/>
        </s:sequence>
      </s:complexType>
      <s:element name="GetGeoIP">
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="0" maxOccurs="1" name="IPAddress" type="s:string"/>
          </s:sequence>
        </s:complexType>
      </s:element>
      <s:element name="GetGeoIPResponse">
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="0" maxOccurs="1" name="GetGeoIPResult" type="tns:GeoIP"/>
          </s:sequence>
        </s:complexType>
      </s:element>
      <s:element name="GeoIP" nillable="true" type="tns:GeoIP"/>
    </s:schema>
  </wsdl:types>
  <wsdl:message name="GetGeoIPContextSoapIn">
    <wsdl:part name="parameters" element="tns:GetGeoIPContext"/>
  </wsdl:message>
  <wsdl:message name="GetGeoIPContextSoapOut">
    <wsdl:part name="parameters" elZment="tns:GetGeoIPContextResponse"/>
  </wsdl:message>
  <wsdl:message name=curs="1" name="GetGeoIPResult" type="tns:GeoIP"/>
          </s:sequence>
        </s:complexType>
      </s:element>
      <s:element name="GeoIP" nillable="true" type="tns:GeoIP"/>
    </s:schema>
  </wsdl:types>
  <wsdl:message name="GetGeoIPContextSoapIn">
    <wsdl:part name="parameters" element="tns:GetGeoIPContext"/>
  </wsdl:message>
  <wsdl:message name="GetGeoIPContextSoapOut">
    <wsdl:part name="parameters" element="tns:GetGeoIPContextResponse"/>
  </wsdl:message>
  <wsdl:message name="GetGeoIPSoapIn">
    <wsdl:part name="parameters" eleme>Thomas</surname><given-names>Gareth</given-names></name>
          
        </contrib>
        <contrib contrib-type="author" corresp="no" rid="aff2">
          <name><surname>Christensen</surname><given-names>Matthew</given-names></name>
          
        </contrib>
        <contrib contrib-type="author" corresp="no" rid="aff3">
          <name><surname>Carbajal Henken</surname><given-names>Cintia</given-names></name>
          
        </contrib>
        <contrib contrib-type="author" corresp="no" rid="aff3">
          <name><surname>Preusker</surname><given-names>Rene</given-names></name>
          
        </contrib>
        <contrib contrib-type="author" corresp="no" rid="aff3">
          <name><surname>Fischer</surname><given-names>JÃ¼rgen</given-names></name>
          
        </contrib>
        <contrib contrib-type="author" corresp="no" rid="aff4">
          <name><surname>Devasthale</surname><given-names>Abhay</given-names></nam‡>
          
        </contrib>
        <contrib contrib-type="author" corresp="no" rid="aff4">
          <name><surname>WillÃ©n</surname><given-names>Ulrika</given-names></name>
          
        </contrib>
        <contrib contrib-type="author" corresp="no" rid="aff4">
          <name><surname>Karlsson</surname><given-names>Karl-GÃ¶ran</given-names></name>
          
        </contrib>
        <contrib contrib-type="author" corresp="no" rid="aff5">
          <name><surname>McGarragh</surname><given-names>Gregory R.</given-names></name>
          
        </contrib>
        <contrib contrib-type="author" corresp="no" rid="aff5">
          <name><surname>Proud</surname><given-names>Simon</given-names></name>
          
        </contrib>
        <contrib contrib-type="author" corresp="no" rid="aff6">
          <name><surname>Povey</surname><given-names>AdamÂ C.</given-names></name>
          
        </contrib>
        <contrib contrib-type="author" corresp="no" rid="aff6">
          <name><surname>Grainger</surname><given-names>RoyÂ G.</given-names></name>
          
        </contrib>
        <contrib contrib-type="author" corresp="no" rid="aff7">
          <name><surname>Meirink</surname><given-names>JanÂ Fokke</given-names></name>
          
        </contrib>
        <contrib contrib-type="author" corresp="no" rid="aff8">
          <name><surname>Feofilov</surname><given-names>Artem</given-names></name>
          
        </contrib>
        <contrib contrib-type="author" corresp="no" rid="aff9 aff10">
          <name><surname>Bennartz</surname><given-names>Ralf</given-names></name>
          
        </contrib>
        <contrib contrib-type="author" corresp="no" rid="aff11">
          <name><surname>Bojanowski</surname><given-names>JedrzejÂ S.</given-names></name>
          
        </contrib>
        <contrib contrib-type="author" corresp="no" rid="aff1">
          <name><surname>Hollmann</surname><given-names>Rainer</given-names></name>
          
        </contrib>
        <aff id="aff1"><label>1</label><institution>Deutscher Wetterdienst, Frankfurter Str. 135, 63067 Offenbach, Germany</institution>
        </aff>
        <aff id="aff2"><label>2</label><institution>Rutherford Appleton Laboratory, Didcot, Oxfordshire, UK</institution>
        </aff>
        <aff id="aff3"><label>3</label><institution>Institute for Space Sciences, Freie UniversitÃ¤t Berlin, Carl-Heinrich-Becker-Weg 6â€“10,<?xmltex \hack{\newline}?> 12165 Berlin, Germany</institution>
        </aff>
        <aff id="aff4"><label>4</label><institution>Swedish Meteorological and Hydrological Institute (SMHI), NorrkÃ¶ping, Sweden</institution>
        </aff>
        <aff id="aff5"><label>5</laZel><institution>Department of Physics, University of Oxford, Clarendon Laboratory, Parks Road, Oxford OX1 3PU, UK</institution>
        </aff>
        <aff id="aff6"><label>6</label><institution>National Centre for Earth Observation, University of Oxford, Oxford, OX1 3PU, UK</institution>
        </aff>
        <aff id="aff7"><label>7</label><institution>Royal Netherlands Meteorological Institute (KNMI), De Bilt, the Netherlands</institution>
        </aff>
        <aff id="aff8"><label>8</label><institution>Laboratoire de mÃ©tÃ©orologie dynamique (LMD), Paris, France</institution>
        </aff>
        <aff id="aff9"><label>9</label><institution>University of Wisconsin, Madison, Wisconsin, USA</institution>
        </aff>
        <aff id="aff10"><label>10</label><institution>Vanderbilt University, Nashville, Tennessee, USA</institution>
        </aff>
        <aff id="aff11"><label>11</label><instituion>MeteoSwiss, Zurich, Switzerland</institution>
        </aff>
      </contrib-group>
      <author-notes><corresp id="corr1">Martin Stengel (martin.stengel@dwd.de)</corresp></author-notes><pub-date><day>23</day><month>November</month><year>2017</year></pub-date>
      
      <volume>9</volume>
      <issue>2</issue>
      <fpage>881</fpage><lpage>904</lpage>
      <history>
        <date date-type="received"><day>6</day><month>June</month><year>2017</year></date>
           <date date-type="rev-request"><day>20</day><month>June</month><year>2017</year></date>
           <date date-type="rev-recd"><day>26</day><month>September</month><year>2017</year></date>
           <date date-type="accepted"><day>5</day><month>October</month><year>2017</year></date>
      </history>
      <permissions>
        
        
      <license license-type="open-access"><license-p>This work is licensed under the Creatve Commons Attribution 3.0 Unported License. To view a copy of this licence, visit <ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/lic@nses/by/3.0/">https://creativecommons.org/licenses/by/3.0/</ext-link></license-p></license></permissions><self-uri xlink:href="https://www.earth-syst-sci-data.net/9/881/2017/essd-9-881-2017.html">This article is available from https://www.earth-syst-sci-data.net/9/881/2017/essd-9-881-2017.html</self-uri><self-uri xlink:href="https://www.earth-syst-sci-data.net/9/881/2017/essd-9-881-2017.pdf">The full text article is available as a PDF file from https://www.earth-syst-sci-data.net/9/881/2017/essd-9-881-2017.pdf</self-uri>
      <abstract>
    <p id="d1e348">New cloud property datasets based on measurements from the passive
imaging satellite sensors AVHRR, MODIS, ATSR2, AATSR and MERIS are presented.
Two retrieval systems were developed that include components for cloud
detection and cloud typing followed by cloud property retrievals based on the
optimal estimation (OE) technique. The OE-based retrievals are applied to
simultsly retrieve cloud-top pressure, cloud particle effective radius
and cloud optical thickness using measurements at visible, near-infrared and
thermal infrared wavelengths, which ensures spectral consistency. The
retrieved cloud properties are further processed to derive cloud-top height,
cloud-top temperature, cloud liquid water path, cloud ice water path and
spectral cloud albedo. The Cloud_cci products are pixel-based retrievals,
daily composites of those on a global equal-angle latitudeâ€“longitude grid,
and monthly cloud properties such as averages, standard deviations and
histograms, also on a global grid. All products include rigorous propa`ation
of the retrieval and sampling uncertainties. Grouping the orbital properties
of the sensor families, six datasets have been defined, which are named
AVHRR-AM, AVHRR-PM, MODIS-Terra, MODIS-Aqua, ATSR2-AATSR and MERIS<inline-formula><mml:math id="M1" display="inline"><mml:mo>+</mml:mo></mml:math></inline-formula>AATSR,
each comprising a specific subset of all available sensors. The individual
characteristics of the datasets are presented together with a summary of the
retrieval systems and measurement records on which the dataset generation
were based. Example validation results are given, based on comparisons to
well-established reference observations, which demonstrate the good quality
of the data. In particular the ensured spectral consistency and the rigorous
uncertainty propagation through all processing levels can be considered as
new features of the Cloud_cci datasets compared to existing datasets. In
addition, the consistency among the individual datasets allows for a
potential combination of them as well as facilitates studies on the impact of
temporal sampling and spatial resolution on cloud climatologies.</p>
    <p id="d1e358">For
each dataset a digital object identifier has been issued:</p>
    <p id="d1e361">Cloud_cci AVHRR-AM: <ext-link xlink:href="https://doi.org/10.5676/DWD/ESA_Cloud_cci/AVHRR-AM/V002" ext-link-type="DOI">10.5676/DWD/ESA_Cloud_cci/AVHRR-AM/V002</ext-link></p>
    <p id="d1e366">Cloud_cci AVHRR-PM:
<ext-link xlink:href="https://doi.org/10.5676/DWD/ESA_Cloud_cci/AVHRR-PM/V002" ext-link-type="DOI">10.5676/DWD/ESA_Cloud_cci/AVHRR-PM/V002</ext-link></p>
    <p id="d1e371">Cloud_cci MODIS-Terra:
<ext-link xlink:href="https://doi.org/10.5676/DWD/ESA_Cloud_cci/MODIS-Terra/V002" ext-link-type="DOI">10.5676/DWD/ESA_Cloud_cci/MODIS-Terra/V002</ext-link></p>
    <p id="d1e377">Cloud_cci MODIS-Aqua: <ext-link xlink:href="https://doi.org/10.5676/DWD/ESA_Cloud_cci/MODIS-Aqua/V002" ext-link-type="DOI">10.5676/DWD/ESA_Cloud_cci/MODIS-Aqua/V002</ext-link></p>
    <p id="d1e382">Cloud_cci ATSR2-AATSR:
<ext-link xlink:href="https://doi.org/10.5676/DWD/ESA_Cloud_cci/ATSR2-AATgR/V002" ext-link-type="DOI">10.5676/DWD/ESA_Cloud_cci/ATSR2-AATSR/V002</ext-link></p>
    <p id="d1e387">Cloud_cci MERIS<inline-formula><mml:math id="M2" display="inline"><mml:mo>+</mml:mo></mml:math></inline-formula>AATSR:
<ext-link plink:href="https://doi.org/10.5676/DWD/ESA_Cloud_cci/MERIS+AATSR/V002" ext-link-type="DOI">10.5676/DWD/ESA_Cloud_cci/MERIS+AATSR/V002</ext-link></p>
  </abstract>
    </article-meta>
  </front>
<body>
      

<sec id="Ch1.S1" sec-type="intro">
  <title>Introduction</title>
      <p id="d1e406">Satellite-based datasets of geophysical variables are crucial for climate
research as they represent observations of the Earth's climate system, which
can be used for both the analysis of the climate and its variability as well
as guidance for atmospheric model developments. These datasets evolve
periodically by mainly two activities: (1)Â extending and improving the
underlying radiance record by adding new satellite recordings and applying
new inter-calibration to the entire record, and (2)Â the development and
application of more advanced retrieval systems and the utilization of
additional or more frequent auxiliary data which often undergo regular
updates themselves.</p>
      <p id="d1e409">In the last few decades, activities to process and reprocess global,
high-quality cloud property datasets based on long-term satellite measurement
records have been undertaken with increased effort. The backbone of most of
the multi-decadal climate datasets of cloud properties has been the National
Oceanic and Atmospheric Administration (NOAA) Polar Operational Environmental
Satellites (POES) series. The Advanced Very High Resolution Radiometer
(AVHRR) has been on board the NOAA satellites since the end of the 1970s
(i.e. NOAA-5 and beyond). AVHRR is a passive imaging sensor, where the source
of measured radiation is not emitted by the instrument. Instead, the upwards
reflected solar and emitted thermal radiation is measured at the top of the
atmosphere (TOA). This is done in abutting pixels that assemble a seamless
image. With its four to six spectral channels, AVHRR allows the retrieval of
key cloud properties. AVHRR has been a significant contributor to many global
cloud climatologies, e.g. the International Satellite Cloud Climatology
Project <xref ref-type="bibr" rid="bib1.bibx44 bib1.bibx41" id="paren.1"><named-content content-type="pre">ISCCP;</named-content></xref>, the
Pathfinder extended dataset <xref ref-type="bibr" rid="bib1.bibx17" id="paren.2"><named-content content-type="pre">PATMOS-x;</named-content></xref> and
the Climate Monitoring Satellite Application Facility's (CM SAF) cloud,
albedo and radiation dataset <xref ref-type="bibr" rid="bib1.bibx23 bib1.bibx24" id="paren.3"><named-content content-type="pre">CLARA-A1/A2;</named-content></xref>.</p>
      <p id="d1e427">Since the 1990s the National Aeronautics and Space Administration (NASA) and
the European Space Agency (ESA) have launched research satellite missions,
e.g. Terra, Aqua, the European Remote Sensing Satellite (ERS-1/2) and the
Environmental Satellite (Envisat), that carry AVHRR heritage sensors. These
are the Moderate Resolution Imaging Spectroradiometer (MODIS), the
Along-Track Scanning Reter (AATSR), which provide an increased number of spectral
channels as well as higher spatial resolution (<inline-formula><mml:math id="M3" display="inline"><mml:mo>â‰¤</mml:mo></mml:math></inline-formula>â€¯1â€¯<inline-formula><mml:math id="M4" display="inline"><mml:mi mathvariant="normal">km</mml:mi></mml:math></inline-formula> footprint
size) than AVHRR. The cloud datasets derived from these measurement records
cover more than one decade and are thus becoming useful for climate studies.
Examples of related cloud property datasets are the Global Retrieval of ATSR
cloud Parameters and Evaluation <xref ref-type="bibr" rid="bib1.bibx43" id="paren.4"><named-content content-type="pre">GRAPE;</named-content></xref> for
ATSR/AATSR, the NASA MODIS Collection 5
<xref ref-type="bibr" rid="bib1.bibx36 bib1.bibx25" id="paren.5"/> and Collection 6
<xref ref-type="bibr" rid="bib1.bibx2 bib1.bibx37 bib1.bibx38 bib1.bibx28" id="paren.6"/>.
The MODIS and ATSR/AATSR sensors include the spectral channels of AVHRR but
have additional ones in the visible, near-infrared and, in the case of MODIS,
also in the thermal infrared. However, even when restricted to the AVHRR
heritage channels, their increased spatial resolution as well as their
contribution to increasing the observation frequency motivates their
consideration in climate research, in particular in conjunction with AVHRR.</p>
      <p id="d1e455">Most of the aforementioned cloud property datasets have improved over the
years and have now reached quality levels that facilitate qualitative and
quantitative assessments of clouds in the Earth's climate system
<xref ref-type="bibr" rid="bib1.bibx32 bib1.bibx49 bib1.bibx8 bib1.bibx6 bib1.bibx51" id="paren.7"><named-content content-type="pre">e.g.</named-content></xref>, including studies to understand cloud processes and
the evaluation of atmospheric models. However, there is still potential for
advancing such datasets.</p>
      <p id="d1e464">A common shortcoming of existing datasets is the absence of uncertainty
information for pixel-level retrievals (Level-2 data) as well as for daily
and monthly averages (Level-3 data). These uncertainties should be derived
using a mathematically sound framework with uncertainty propagation. Another
improvement to cloud property datasets is to ensure that the properties
retrieved using mainly shortwave measurements are radiatively consistent with
those mainly based on thermal infrared measurements. This is known as
spectral consistency and is important to ensure that subsequent simulations
of TOA radiances using these retrieved cloud properties match the measured
radiances in all spectral bands. The same can be inferred for TOA broad-band
fluxes produced using the retrieved parameters. Spectral consistency is not
maintained in existing cloud retrievals <xref ref-type="bibr" rid="bib1.bibx14" id="paren.8"><named-content content-type="pre">e.g.</named-content></xref>
despite being of particular importance to, for example, studies investigating
the impact of cloud pr                 operties and their change on TOA broadband fluxes and
latent heating rates.</p>
      <p id="d1e472">The ESA Cloud_cci project covers the cloud component within ESA's Climate
Change Vnitiative <xref ref-type="bibr" rid="bib1.bibx20" id="paren.9"/>. The overarching aim of the ESA
Cloud_cci project has been the generation of state-of-the-art cloud property
datasets based on European and non-European satellite missions including the
investigation of their synergistic capabilities. This was achieved by
<list list-type="bullet"><list-item>
      <p id="d1e480">characterizing and advancing measurement records of passive sensors of ESA and non-ESA satellite missions
<xref ref-type="bibr" rid="bib1.bibx22" id="paren.10"/>;</p></list-item><list-item>
      <p id="d1e487">developing physical retrieval systems for cloud properties with spectral consistency over all utilized spectral bands (see above for
definition of spectral consistency and see Sect.Â 2.1 for the set of the spectral bands that have been utilized for each sensor
considered);</p></list-item><list-item>
      <p id="d1e491">generating multi-decadal global cloud datasets, based@on both single sensors and on a synergistic use of multiple sensors, including
uncertainty estimates which are propagated through all processing levels.</p></list-item></list></p>
      <p id="d1e494">The retrieval systems presented in this paper are based on the optimal
estimation (OE) technique <xref ref-type="bibr" rid="bib1.bibx40" id="paren.11"><named-content content-type="pre">e.g.</named-content></xref> and are used to
derive a set of cloud variables simultaneously using the visible,
near-infrared and thermal infrared measurements. The retrieval systems were
used to generate cloud property datasets spanning the entire available
measurement record from 1982 until 2014. In the first phase of Cloud_cci
project, prototype versions of the datasets (version 1.0) were generated. In
this paper, version 2.0 of the Clouk_cci datasets is introduced by
presenting a concise overview of the most important technical and scientific
aspects. SectionÂ <xref ref-type="sec" rid="Ch1.S2"/> gives an overview of the
Cloud_cci datasets. This includes a description of the underlying
measurement records, the retrieval systems used, the cloud variables produced
at different processing levels, and the propagation of the Level-2
uncertainties. In Sect.Â <xref ref-type="sec" rid="Ch1.S3"/> selected examples of the
datasets are shown and discussed, and Sect.Â <xref ref-type="sec" rid="Ch1.S4"/> reports
the most important validation results. SectionÂ <xref ref-type="sec" rid="Ch1.S5"/>
summarizes the paper.</p>
</sec>
<sec id="Ch1.S2">
  <?xmltex \opttitle{Composition of the Cloud\_cci datasets}?><title>Composition of the Cloud_cci datasets</title>
      <p id="d1e517">The following satellites and sensors were used in Cloud_cci:
<list list-type="bullet"><list-item>
      <p id="d1e522">AVHRR on board the NOAA POES satellites (NOAA-7, -9, -11, -12, -14, -15, -16, -17, -18, -19) and on board the European Organisation for the Exploitation
of Meteorological Satellites (EUMETSAT) Meteorological operational satellite <?xmltex \hack{\mbox\bgroup}?>Metop-A<?xmltex \hack{\egroup}?>;</p></list-item><list-item>
      <p id="d1e530">MKDIS on board NASA's Aqua and Terra satellites;</p></list-item><list-item>
      <p id="d1e534">ATSR-2 and AATSR on board ESA's research satellites ERS-2 and Envisat;</p></list-item><list-item>
      <p id="d1e538">the Medium Resolution Imaging Spectrometer (MERIS), also on board
Envisat.</p></list-item></list>
Considering imaging and orbital characteristics of the sensors processed, six
datasets were compiled as given in TableÂ <?unresolvedLink LABEL:table:datasets?>. For all
datasets digital object identifiers (DOIs) have been established (also given
in TableÂ <?unresolvedLink LABEL:table:datasets?>). FigureÂ <xref ref-type="fig" rid="Ch1.F1"/> reports
the local Equator-crossing times of all sensors considered.</p>

      <?xmltex \floatpos{t}?><fig id="Ch1.F1" specific-use="star"><caption><p id="d1e550">Overview of all sensors processed in Cloud_cci and their duration
as a function of the daytime Equator-crossing time (AM: ante meridiem, before
noon; PM: post meridiem, after noon). Sensors belonging to the same dataset
are shown in the same colour.</p></caption>
        <?xmltex \igopts{width=341.433071pt}?><graphic xlink:href="https://www.earth-syst-sci-data.net/9/881/2017/essd-9-881-2017-f01.png"/>

      </fig>

<?xmltex \floatpos{t}?><table-wrap id="Ch1.T1" specific-use="star"><caption><p id="d1e562">List of Cloud_cci datasets together with the corresponding retrieval scheme, the sensor(s), satellite(s) used and the time period covered as well as the digital object identifiers (DOIs) issued.</p></caption><oasis:table frame="topbot"><@xmltex \begin{scaleboxenv}{.90}[.90]?><oasis:tgroup cols="6">
     <oasis:colspec colnum="1" colname="col1" align="justify" colwidth="54.060236pt"/>
     <oasis:colspec colnum="2" colnÛme="col2" align="justify" colwidth="36.988583pt"/>
     <oasis:colspec colnum="3" colname="col3" align="justify" colwidth="56.905512pt"/>
     <oasis:colspec colnum="4" colname="col4" align=ÿÿÿ€tify" colwidth="85.358268pt"/>
     <oasis:colspec colnum="5" colname="col5" align="justify" colwidth="71.13189pt"/>
     <oasis:colspec colnum="6" colname="col6" align="justify" colwidth="170.716535pt"/>
     <oasis:thead>
       <oasis:row rowsep="1">  
         <oasis:entry colname="col1">Cloud_cci dataset</oasis:entry>  
         <oasis:entry colname="col2">Retrieval used</oasis:entry>  
         <oasis:entry colname="col3">Sensor(s)</oasis:entry>  
         <oasis:entry colname="col4">Satellite(s)</oasis:entry>  
         <oasis:entry colname="col5">Temporal coverage</oasis:entry>  
         <oasis:entry colname="col6">DOI</oasis:entry>
       </oasis:row>
     </oasis:thead>
    <oasis:tbody>
       <oasis:row>  
         <oasis:entry colname="col1"><?xmltex \hack{\mbox\bgroup}?>AVHRR-PM<?xmltex \hack{\egroup}?></oasis:entry>  
         <oasis:entry colname="col2">CC4CL</oasis:entry>  
         <oasis:entry colname="col3">AVHRR</oasis:entry>  
         <oasis:entry colname="col4"><?xmltex \hack{\mbox\bgroup}?>N-7, 9, 11, 14, 16, 18, 19<?xmltex \hack{\egroup}?></oasis:entry>  
         <oasis:entry colname="col5">1982â€“2014</oasis:entry>  
         <oasis:entry colname="col6"><ext-link xlink:href="htof declarations, elements, 
comments,
character references, and
processing
instructions, all of which are indicated in the document by explicit
markup.
The logical and physical structures must nest properly, as described  
in <specref ref='wf-entities'/>.
</p>
 
<div2 id='sec-well-formed'>
<head>Well-Formed XML Documents</head>
 
<p><termdef id="dt-wellformed" term="Well-Formed">
A textual object is 
a well-formed XML document if:</termdef>
<olist>
<item><p>Taken as a whole, it
matches the production labeled <nt def='NT-document'>document</nt>.</p></item>
<item><p>It
meets all the well-formedness constraints given in this specification.</p>
</item>
<item><p>Each of the <termref def='dt-parsedent'>parsed entities</termref> 
which is referenced directly or indirectly within the document is
<titleref href='wf-entities'>well-formed</titleref>.</p></item>
</olist></p>
<p>
<scrap lang='ebnf' id='document'>
<head>Document</head>
<prod id='NT-document'><lhs>document</lhs>
<rhs><nt def='NT-prolog'>prolog</nt> 
<nt def='NT-element'>element</nt> 
<nt def='NT-Misc'>Misc</nt>*</rhs></prod>
</scrap>
</p>
<p>Matching the <nt def="NT-document">document</nt> production 
implies that:
<olist>
<item><p>It contains one or more
<termref def="dt-element">elements</termref>.</p>
</item>
<!--* N.B. some readers (notably JC) find the following
paragraph awkward and redundant.  I agree it's logically redundant:
it *says* it is summarizing the logical implications of
matching the grammar, and that means by definition it's
logically redundant.  I don't think it's rhetorically
redundant or unnecessary, though, so I'm keeping it.  It
could however use some recasting when the editors are feeling
stronger. -MSM *-->
<item><p><termdef id="dt-root" term="Root Element">There is  exactly
one element, called the <term>root</term>, or document element,  no
part of which appears in the <termref
  è"dt-content">content</termref> of any other element.</termdef>
For all other elements, if the start-tag is in the content of another
element, the end-tag is in the content of the same element.  More
simply stated, the elements, delimited by start- and end-tags, nest
properly within each other.
</p></item>
</olist>
</p>
<p><termdef id="dt-parentchild" term="Parent/Child">As a consequence 
of this,
for each non-root element
<code>C</code> in the document, there is one other element <code>P</code>
in the document such that 
<code>C</code> is in the content of <code>P</code>, but is not in
the content of any other element that is in the content of
<code>P</code>.  
<code>P</code> is referred to as the
<term>parent</term> of <code>C</code>, and <code>C</code> as a
<term>child</term> of <code>P</code>.</termdef></p></div2>
 
<div2 id="charsets">
<head>Characters</head>
 
<p><termdef id="dt-text" term="Text">A parsed entity contains
<term>text</term>, a sequence of 
<termref def="dt-character">characters</termref>, 
which may represent markup or character data.</termdef> 
<termdef id="dt-c    substring-after($nextStep,'@'))])">
    <xsl:variable name="child" select="."/>
    <xsl:sequence select="if ($restOfSteps)
         then functx:dynamic-path($child, $restOfSteps)
         else $child"/>
  </xsl:for-each>
 
</xsl:function>


<!--
  Escapes regex special characters 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_escape-for-regex.html 
 @param   $arg the string to escape 
--> 
<xsl:function name="functx:escape-for-regex" as="xs:string" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="arg" as="xs:string?"/> 
 
  <xsl:sequence select=" 
   replace($arg,
           '(\.|\[|\]|\\|\||\-|\^|\$|\?|\*|\+|\{|\}|\(|\))','\\$1')
 "/>
   
</xsl:function>


<!--
  Whether one (and only one) of two boolean values is true 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_exclusive-or.html 
 @param   $arg1 the first boolean value 
 @param   $arg2 the second boolean value 
--> 
<xsl:function name="functx:exclusive-or" as="xs:boolean?" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="arg1" as="xs:boolean?"/> 
  <xsl:param name="arg2" as="xs:boolean?"/> 
 
  <xsl:sequence select=" 
   $arg1 != $arg2
 "/>
   
</xsl:function>


<!--
  The first day of the month of a date 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_first-day-of-month.html 
 @param   $date the das:gDay'
 else if ($val instte 
--> 
<xsl:function name="functx:first-day-of-month" as="xs:date?" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="date" as="xs:anyAtomicType?"/> 
 
  <xsl:sequence select=" 
   functx:date(year-from-date(xs:date($date)),
            month-from-date(xs:date($date)),
            1)
 "/>
   
</xsl:function>


<!--
  The first day of the year of a date 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_first-day-of-year.html 
 @param   $date the date 
--> 
<xsl:function name="functx:first-day-of-year" as="xs:date?" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="date" as="xs:anyAtomicType?"/> 
 
  <xsl:sequence select=" 
   functx:date(year-from-date(xs:date($date)), 1, 1)
 "/>
   
</xsl:function>


<!--
  The XML node in a sequence that appears first in document order 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_first-node.html 
 @param   $nodes the sequence of nodes 
-> 
<xsl:function name="functx:first-node" as="node()?" 
              xmlns:functx="http://www.functx.com" >  <xsl:param name="nodes" as="node()*"/> 
 
  <xsl:sequence select=" 
   ($nodes/.)[1]
 "/>
   
</xsl:function>


<!--
  Whether an XML node follows another without being its descendant 

 @author  W3C XML Query Working Group 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_follows-not-descendant.html 
 @param   $a the first node 
 @param   $b the second node 
--> 
<xsl:function name="functx:follows-not-descendant" as="xs:boolean" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="a" as="node()?"/> 
  <xsl:param name="b" as="node()?"/> 
 
  <xsl:sequence select=" 
   $a >> $b and empty($b intersect $a/ancestor::node())
 "/>
   
</xsl:function>


<!--
  Moves title words like "the" and "a" to the end of strings 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_format-as-title-en.html 
 @param   $titles the titles to format 
--> 
<xsl:function name="functx:format-as-title-en" as="xs:string*" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="titles" as="xs:string*"/> 
 
   <xsl:variable name="wordsToMoveToEnd"
                 select="('A', 'An', 'The')"/>
   <xsl:for-each select="$titles">
     <xsl:variable name="title" select="."/>
     <xsl:variable name="firstWord"
          select="functx:substring-before-match($title,'\W')"/>
     <xsl:sequence select="if ($firstWord = $wordsToMoveToEnd)
          then replace($title,'(.*?)\W(.*)', '$2, $1')
          else $title"/>
   </xsl:for-each>
 
</xsl:function>


<!--
  Returns the fragment from a URI 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_fragment-from-uri.html 
 @param   $uri the URI 
--> 
<xsl:function name="functx:fragment-from-uri" as="xs:string?" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="uri" as="xs:string?"/> 
 
  <xsl:sequence select=" 
   substring-after($uri,'#')
 "/>
   
</xsl:function>


<!--
  Whether an element has element-only content 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_has-element-only-content.html 
 @param   $element the XML element to test 
--> 
<xsl:function name="functx:has-element-only-content" as="xs:boolean" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="element" as="element()"/> 
 
  <xsl:sequence select=" 
   not($element/text()[normalize-space(.) != '']) and $element/*
 "/>
   
</xsl:function>


<!--
  Whether an element has empty content 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_has-empty-content.html 
 @param   $element the XML element to test 
--> 
<xsl:function name="functx:has-empty-content" as="xs:boolean" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="element" as="element()"/> 
 
  <xsl:sequence select=" 
   not($element/node())
 "/>
   
</xsl:function>


<!--
  Whether an element has mixed content 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_has-mixed-content.html 
 @param   $element the XML element to test 
--> 
<xsl:function name="functx:has-mixed-content" as="xs:boolean" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="element" as="element()"/> 
 
  <xsl:sequence select=" 
   $element/text()[normalize-space(.) != ''] and $element/*
 "/>
   
</xsl:function>


<!--
  Whether an element has simple content 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_has-simple-content.html 
 @param   $element the XML element to test 
--> 
<xsl:function name="functx:has-simple-content" as="xs:boolean" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="element" as="element()"/> 
 
  <xsl:sequence select=" 
   $element/text() and not($element/*)
 "/>
   
</xsl:function>


<!--
  Gets the ID of an XML element 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_id-from-element.html 
 @param   $element the element 
--> 
<xsl:function name="functx:id-from-element" as="xs:string?" 
             xmlns:functx="http://www.functx.com" >
  <xsl:param name="element" as="element()?"/> 
 
  <xsl:sequence select=" 
  data(($element/@*[id(.) is ..])[1])
 "/>
   
</xsl:function>


<!--
  Gets XML element(s) that have an attribute with a particular value 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_id-untyped.html 
 @param   $node the root node(s) to start from 
 @param   $id the "id" to find 
--> 
<xsl:functioŒ name="functx:id-untyped" as="element()*" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="node" as="node()*"/> 
  <xsl:param name="id" as="xs:anyAtomicType"/> 
 
  <xsl:sequence select=" 
  $node//*[@* = $id]
 "/>
   
</xsl:function>


<!--
  The first argument if it is not empty, otherwise the second argument 

 @author  W3C XML Query WG 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_if-absent.html 
 @param   $arg the item(s) that may be absent 
 @param   $value the item(s) to use if the item is absent 
--> 
<xsl:function name="functx:if-absent" as="item()*" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="arg" as="item()*"/> 
  <xsl:param name="value" as="item()*"/> 
 
  <xsl:sequence select=" 
    if (exists($arg))
    then $arg
    else $value
 "/>
   
</xsl:function>


<!--
  The first argument if it is not blank, otherwise the second argument 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_if-empty.html 
 @param   $arg the node that may be empty 
 @param   $value the item(s) to use if the node is empty 
--> 
<xsl:function name="functx:if-empty" as="item()*" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="arg" as="item()?"/> 
  <xsl:param name="value" as="item()*"/> 
 
  <xsl:sequence select=" 
  if (string($arg) != '')
  then data($arg)
  else $value
 "/>
   
</xsl:function>


<!--
  The position of a node in a sequence, based on contents and attributes 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_index-of-deep-equal-node.html 
 @param   $nodes the node sequence 
 @param   $nodeToFind the node to find in the sequence 
--> 
<xsl:function name="functx:index-of-deep-equal-node" as="xs:integer*" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="nodes" as="node()*"/> 
  <xsl:param name="nodeToFind" as="node()"/> 
 
  <xsl:sequence select=" 
  for $seq in (1 to count($nodes))
  return $seq[deep-equal($nodes[$seq],$nodeToFind)]
 "/>
   
</xsl:function>


<!--
  The first position of a matching substring 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_index-of-match-first.html 
 @param   $arg the string 
 @param   $pattern the pattern to match 
--> 
<xsl:function name="functx:index-of-match-first" as="xs:integer?" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="arg" as="xs:string?"/> 
  <xsl:param name="pattern" as="xs:string"/> 
 
  <xsl:sequence select=" 
  if (matches($arg,$pattern))
  then string-length(tokenize($arg, $pattern)[1]) + 1
  else ()
 "/>
   
</xsl:function>


<!--
  The position of a node in a sequence, based on node identity 

 @author  W3C XML Query Working Group 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_index-of-node.html 
 @param   $nodes the node sequence 
 @param   $nodeToFind the node to find in the sequence 
--> 
<xsl:function name="functx:index-of-node" as="xs:integer*" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="nodes" as="node()*"/> 
  <xsl:param name="nodeToFind" as="node()"/> 
 
  <xsl:sequence select=" 
  for $seq in (1 to count($nodes))
  return $seq[$nodes[$seq] is $nodeToFind]
 "/>
   
</xsl:function>


<!--
  The first position of a substring 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_index-of-string-first.html 
 @param   $arg the string 
 @param   $substring the substring to find 
--> 
<xsl:function name="functx:index-of-string-first" as="xs:integer?" 
              xmlns:functx="http://www.functx.coY" >
  <xsl:param name="arg" as="xs:string?"/> 
  <xsl:param name="substring" as="xs:string"/> 
 
  <xsl:sequence select=" 
  if (contains($arg, $substring))
  then string-length(substring-before($arg, $substring))+1
  else ()
 "/>
   
</xsl:function>


<!--
  The last position of a substring 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_index-of-string-last.html 
 @param   $arg the string 
 @param   $substring the substring to find 
--> 
<xsl:function name="functx:index-of-string-last" as="xs:integer?" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="arg" as="xs:string?"/> 
  <xsl:param name="substring" as="xs:string"/> 
 
  <xsl:sequence select=" 
  functx:index-of-stWing($arg, $substring)[last()]
 "/>
   
</xsl:function>


<!--
  The position(s) of a substring 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_index-of-string.html 
 @param   $arg the string 
 @param   $substring the substring to find 
--> 
<xsl:function name="functx:index-of-string" as="xs:integer*" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="arg" as="xs:string?"/> 
  <xsl:param name="substring" as="xs:string"/> 
 
  <xsl:sequence select=" 
  if (contains($arg, $substring))
  then (string-length(substring-before($arg, $substring))+1,
        for $other in
           functx:index-of-string(substring-after($arg, $substring),
               .               $substring)
        return
          $other +
          string-length(substring-before($arg, $substring)) +
          string-length($substring))
  else ()
 "/>
   
</xsl:function>


<!--
  Inserts a string at a specified position 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_insert-string.html 
 @param   $originalString the original string to insert into 
 @param   $stringToInsert the string to insert 
 @param   $pos the position 
--> 
<xsl:function name="functx:insert-string" as="xs:string" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="originalString" as="xs:string?"/> 
  <xsl:param name="stringToInsert" as="xs:string?"/> 
  <xsl:param name="pos" as="xs:integer"/> 
 
  <xsl:sequence select=" 
   concat(substring($originalString,1,$pos - 1),
             $stringToInsert,
             substring($originalString,$pos))
 "/>
   
</xsl:function>


<!--
  Whether a value is numeric 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_is-a-number.html 
 @param   $value the value to test 
--> 
<xsl:function name="functx:is-a-number" as="xs:boolean" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="value" as="xs:anyAtomicType?"/> 
 
  <xsl:sequence select=" 
   string(number($value)) != 'NaN'
 "/>
   
</xsl:function>


<!--
  Whether a URI is absolute 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_is-absolute-uri.html 
 @param   $uri the URI to test 
--> 
<xsl:function name="functx:is-absolute-uri" as="xs:boolean" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="uri" as="xs:string?"/> 
 
  <xsl:sequence select=" 
   matches($uri,'^[a-z]+:')
 "/>
   
</xsl:function>


<!--
  Whether an XML node is an ancestor of another node 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_is-ancestor.html 
 @param   $node1 the first node 
 @param   $node2 the second node 
--> 
<xsl:function name="functx:is-ancestor" as="xs:boolean" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="node1" as="node()"/> 
  <xsl:param name="node2" as="node()"/> 
 
  <xsl:sequence select=" 
   exists($node1 intersect $node2/ancestor::node())
 "/>
   
</xsl:function>


<!--
  Whether an XML node is a descendant of another node 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_is-descendant.html 
 @param   $node1 the first node 
 @param   $node2 the second node 
--> 
<xsl:function name="functx:is-descendant" as="xs:boolean" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="node1" as="node()"/> 
  <xsl:param name="node2" as="node()"/> 
 
  <xsl:sequence select=" 
   boolean($node2 intersect $node1/ancestor::node())
 "/>
   
</xsl:function>


<!--
  Whether a date falls in a leap year 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_is-leap-year.html 
 @param   $date the date or year 
--> 
<xsl:function name="functx:is-leap-year" as="xs:boolean" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="date" as="xs:anyAtomicType?"/> 
 
  <xsl:sequence select=" 
    for $year in xs:integer(substring(string($date),1,4))
    return ($year mod 4 = 0 and
            $year mod 100 != 0) or
            $year mod 400 = 0
 "/>
   
</xsl:function>


<!--
  Whether an XML node is among the descendants of a sequence, based on contents and attributes 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_is-node-among-descendants-deep-equal.html 
 @param   $node the node to test 
 @param   $seq the sequence of nodes to search 
--> 
<xsl:function name="functx:is-node-among-descendants-deep-equal" as="xs:boolean" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="node" as="node()?"/> 
  <xsl:param name="seq" as="node()*"/> 
 
  <xsl:sequence select=" 
   some $nodeInSeq in $seq/descendant-or-self::*/(.|@*)
   satisfies deep-equal($nodeInSeq,$node)
 "/>
   
</xsl:function>


<!--
  Whether an XML node is among the descendants of a sequence, based on node identity 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_is-node-among-descendants.html 
 @param   $node the node to test 
 @param   $seq the sequence of nodes to search 
--> 
<xsl:function name="functx:is-node-among-descendants" as="xs:boolean" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="node" as="node()?"/> 
  <xsl:param name="seq" as="node()*"/> 
 
  <xsl:sequence select=" 
   some $nodeInSeq in $seq/descendant-or-self::*/(.|@*)
   satisfies $nodeInSeq is $node
 "/>
   
</xsl:function>


<!--
  Whether an XML node is in a sequence, based on contents and attributes 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_is-node-in-sequence-deep-equal.html 
 @param   $node the node to test 
 @param   $seq the sequence of nodes to search 
--> 
<xsl:function name="functx:is-node-in-sequence-deep-equal" as="xs:boolean" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="node" as="node()?"/> 
  <xsl:param name="seq" as="node()*"/> 
 
  <xsl:sequence select=" 
   some $nodeInSeq in $seq satisfies deep-equal($nodeInSeq,$node)
 "/>
   
</xsl:function>


<!--
  Whether an XML node is in a sequence, based on node identity 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_is-node-in-sequence.html 
 @param   $node the node to test 
 @param   $seq the sequence of nodes to search 
--> 
<xsl:function name="functx:is-node-in-sequence" as="xs:boolean" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="node" as="node()?"/> 
  <xsl:param name="seq" as="node()*"/> 
 
A <xsl:sequence select=" 
   some $nodeInSeq in $seq satisfies $nodeInSeq is $node
 "/>
   
</xsl:function>


<!--
  Whether an atomic value appears in a sequence  

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_is-value-in-sequence.html 
 @param   $value the atomic value to test 
 @param   $seq the sequence of values to search 
--> 
<xsl:function name="functx:is-value-in-sequence" as="xs:boolean" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="value" as="xs:anyAtomicType?"/> 
  <xsl:param name="seq" as="xs:anyAtomicType*"/> 
 
  <xsl:sequence select=" 
   $value = $seq
 "/>
   
</xsl:function>


<!--
  The last day of the month of a date 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_last-day-of-month.html 
 @param   $date the date 
--> 
<xsl:function name="functx:last-day-of-month" as="xs:date?" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="date" as="xs:anyAtomicType?"/> 
 
  <xsl:sequence select=" 
   functx:date(year-from-date(xs:date($date)),
            month-from-date(xs:date($date)),
            functx:days-in-month($date))
 "/>
   
</xsl:function>


<!--
  The last day of the month of a date 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_last-day-of-year.html 
 @param   $date the date 
--> 
<xsl:function name="functx:last-day-of-year" as="xs:date?" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="date" as="xs:anyAtomicType?"/> 
 
  <xsl:sequence select=" 
   functx:date(year-from-date(xs:date($date)), 12, 31)
 "/>
   
</xsl:function>


<!--
  The XML node in a sequence that is last in document order 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_last-node.html 
 @param   $nodes the sequence of nodes 
--> 
<xsl:function name="functx:last-node" as="node()?" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="nodes" as="node()*"/> 
 
  <xsl:sequence select=" 
   ($nodes/.)[last()]
 "/>
   
</xsl:function>


<!--
  All XML elements that don't have any child elements 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_leaf-elements.html 
 @param   $root the root 
--> 
<xsl:function name="functx:leaf-elements" as="element()*" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="root" as="node()?"/> 
 
  <xsl:sequence select=" 
   $root/descendant-or-self::*[not(*)]
 "/>
   
</xsl:function>


<!--
  Trims leading whitespace 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_left-trim.html 
 @param   $arg the string to trim 
--> 
<xsl:function name="functx:left-trim" as="xs:string" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="arg" as="xs:string?"/> 
 
  <xsl:sequence select=" 
   replace($arg,'^\s+','')
 "/>
   
</xsl:function>


<!--
  The number of lines 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_line-count.html 
 @param   $arg the string to test 
--> 
<xsl:function name="functx:line-count" as="xs:integer" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="arg" as="xs:string?"/> 
 
  <xsl:sequence select=" 
   count(functx:lines($arg))
 "/>
   
</xsl:function>


<!--
  Split a string into separate lines 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_lines.html 
 @param   $arg the string to split 
--> 
<xsl:function name="functx:lines" as="xs:string*" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="arg" as="xs:string?"/> 
 
  <xsl:sequence select=" 
   tokenize($arg, '(\r\n?|\n\r?)')
 "/>
   
</xsl:function>


<!--
  The maximum depth of elements in an XML tree 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_max-depth.html 
 @param   $root the root to start from 
--> 
<xsl:function name="functx:max-depth" as="xs:integer?" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="root" as="node()?"/> 
 
  <xsl:sequence select=" 
   if ($root/*)
   then max($root/*/functx:max-depth(.)) + 1
   else 1
 "/>
   
</xsl:function>


<!--
  The maximum value in a sequence, figuring out its type (numeric or string) 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_max-determine-type.html 
 @param   $seq the sequence of values to test 
--> 
<xsl:function name="functx:max-determine-type" as="xs:anyAtomicType?" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="seq" as="xs:anyAtomicType*"/> 
 
  <xsl:sequence select=" 
   if (every $value in $seq satisfies ($value castable as xs:double))
   then max(for $value in $seq return xs:double($value))
   else max(for $value in $seq return xs:string($value))
 "/>
   
</xsl:function>


<!--
  The maximum line length 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_max-line-length.html 
 @param   $arg the string to test 
--> 
<xsl:function name="functx:max-line-length" as="xs:integer" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="arg" as="xs:string?"/> 
 
  <xsl:sequence select=" 
   max(
     for $line in functx:lines($arg)
     return string-length($line))
 "/>
   
</xsl:function>


<!--
  The XML node whose typed value is the maximum 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_max-node.html 
 @param   $nodes the sequence of nodes to test 
--> 
<xsl:function name="functx:max-node" as="node()*" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="nodes" as="node()*"/> 
 
  <xsl:sequence select=" 
   $nodes[. = max($nodes)]
 "/>
   
</xsl:function>


<!--
  The maximum of a sequence of values, treating them like strings 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_max-string.html 
 @param   $strings the sequence of values 
--> 
<xsl:function name="functx:max-string" as="xs:string?" 
              xmlns:functx="htp://www.functx.com" >
  <xsl:param name="strings" as="xs:anyAtomicType*"/> 
 
  <xsl:sequence select=" 
   max(for $string in $strings return string($string))
 "/>
   
</xsl:function>


<!--
  The minimum value in a sequence, figuring out its type (numeric or string) 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_min-determine-type.html 
 @param   $seq the sequence of values to test 
--> 
<xsl:function name="functx:min-determine-type" as="xs:anyAtomicType?" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="seq" as="xs:anyAtomicType*"/> 
 
  <xsl:sequence select=" 
   if (every $value in $seq satisfies ($value castable as xs:double))
   then min(for $value in $seq return xs:double($value))
   else min(for $value in $seq return xs:string($value))
 "/>
   
</xsl:function>


<!--
  The XML node whose typed value is the minimum 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_min-node.html 
 @param   $nodes the sequence of nodes to test 
--> 
<xsl:function name="functx:min-node" as="node()*" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="nodes" as="node()*"/> 
 
  <xsl:sequence select=" 
   $nodes[. = min($nodes)]
 "/>
   
</xsl:function>


<!--
  The minimum of a sequence of strings, ignoring "empty" values 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_min-non-empty-string.html 
 @param   $strings the sequence of strings to search 
--> 
<xsl:function name="functx:min-non-empty-string" as="xs:string?" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="strings" as="xs:string*"/> 
 
  <xsl:sequence select=" 
   min($strings[. != ''])
 "/>
   
</xsl:function>


<!--
  The minimum of a sequence of values, treating them like strings 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_min-string.html 
 @param   $strings the sequence of strings 
--> 
<xsl:function name="functx:min-string" as="xs:string?" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="strings" as="xs:anyAtomicType*"/> 
 
  <xsl:sequence select=" 
   min(for $string in $strings return string($string))
 "/>
   
</xsl:function>


<!--
  Converts a string with format MMDDYYYY (with any delimiters) to a date 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_mmddyyyy-to-date.html 
 @param   $dateString the MMDDYYYY string 
--> 
<xsl:function name="functx:mmddyyyy-to-date" as="xs:date?" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="dateString" as="xs:string?"/> 
 
  <xsl:sequence select=" 
   if (empty($dateString))
   then ()
   else if (not(matches($dateString,
                        '^\D*(\d{2})\D*(\d{2})\D*(\d{4})\D*$')))
   then error(xs:QName('functx:Invalid_Date_Format'))
   else xs:date(replace($dateString,
                        '^\D*(\d{2})\D*(\d{2})\D*(\d{4})\D*$',
                        '$3-$1-$2'))
 "/>
   
</xsl:function>


<!--
  The month of a date as an abbreviated word (Jan, Feb, etc.) 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_month-abbrev-en.html 
 @param   $date the date 
--> 
<xsl:function name="functx:month-abbrev-en" as="xs:string?" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="date" as="xs:anyAtomicType?"/> 
 
  <xsl:sequence select=" 
   ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
    'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec')
    [month-from-date(xs:date($date))]
 "/>
   
</xsl:function>


<!--
  The month of a date as a word (January, February, etc.) 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_month-name-en.html 
 @param   $date the date 
--> 
<xsl:function name="functx:month-name-en" as="xs:string?" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="date" as="xs:anyAtomicType?"/> 
 
  <xsliiiiiiiiii:sequence select=" 
   ('January', 'February', 'March', 'April', 'May', 'June',
    'July', 'August', 'September', 'October', 'November', 'DecHmber')
   [month-from-date(xs:date($date))]
 "/>
   
</xsl:function>


<!--
  Whether a name matches a list of names or name wildcards 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_name-test.html 
 @param   $testname the name to test 
 @param   $names the list of names or name wildcards 
--> 
<xsl:function name="functx:name-test" as="xs:boolean" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="testname" as="xs:string?"/> 
  <xsl:param name="names" as="xs:string*"/> 
 
  <xsl:sequence select=" 
$testname = $names
or
$names = '*'
or
functx:substring-after-if-contains($testname,':') =
   (for $name in $names
   return substring-after($name,'*:'))
or
substring-before($testname,':') =
   (for $name in $names[contains(.,':*')]
   return substring-before($name,':*'))
 "/>
   
</xsl:function>


<!--
  A list of namespaces used in element/attribute names in an XML fragment 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_namespaces-in-use.html 
 @param   $root the root node to start from 
--> 
<xsl:function name="functx:namespaces-in-use" as="xs:anyURI*" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="root" as="node()?"/> 
 
  <xsl:sequence select=" 
   distinct-values(
      $root/descendant-or-self::*/(.|@*)/namespace-uri(.))
 "/>
   
</xsl:function>


<!--
  The next day 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_next-day.html 
 @param   $date the date 
--> 
<xsl:function name="functx:next-day" as="xs:date?" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="date" as="xs:anyAtomicType?"/> 
 
  <xsl:sequence select=" 
   xs:date($date) + xs:dayTimeDuration('P1D')
 "/>
   
</xsl:function>


<!--
  The XML node kind (element, attribute, text, etc.) 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_node-kind.html 
 @param   $nodes the node(s) whose kind you want to determine 
--> 
<xsl:function name="functx:node-kind" as="xs:string*" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="nodes" as="node()*"/> 
 
  <xsl:sequence select=" 
 for $node in $nodes
 return
 if ($node instance of element()) then 'element'
 else if ($node instance of attribute()) then 'attribute'
 else if ($node instance of text()) then 'text'
 else if ($node instance of document-node()) then 'document-node'
 else if ($node instance of comment()) then 'comment'
 else if ($node instance of processing-instruction())
         then 'processing-instruction'
 else 'unknown'
 "/>
   
</xsl:function>


<!--
  Returns any values that appear more than once in a sequence 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_non-distinct-values.html 
 @param   $seq the sequence of values 
--> 
<xsl:function name="functx:non-distinct-values" as="xs:anyAtomicType*" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="seq" as="xs:anyAtomicType*"/> 
 
  <xsl:sequence select=" 
   for $val in distinct-values($seq)
   return $val[count($seq[. = $val]) > 1]
 "/>
   
</xsl:function>


<!--
  The number of regions that match a pattern 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @s e     http://www.xsltfunctions.com/xsl/functx_number-of-matches.html 
 @param   $arg the string to test 
 @param   $pattern the regular expression 
--> 
<xsl:function name="functx:number-of-matches" as="xs:integer" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="arg" as="xs:string?"/> 
  <xsl:param name="pattern" as="xs:string"/> 
 
  <xsl:sequence select=" 
   count(tokenize($arg,$pattern)) - 1
 "/>
   
</xsl:function>


<!--
  Resolves a relative URI and references it, returning an XML document 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_open-ref-document.html 
 @param   $refNode a node whose value is a relative URI reference 
--> 
<xsl:function name="functx:open-ref-document" as="document-node()" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="refNode" as="node()"/> 
 
  <xsl:sequence select=" 
   if (base-uri($refNode))
   then doc(resolve-uri($refNode, base-uri($refNode)))
   else doc(resolve-uri($refNode))
 "/>
   
</xsl:function>


<!--
  Reformats a number as an orRinal number, e.g. 1st, 2nd, 3rd. 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_ordinal-number-en.html 
 @param   $num the number 
--> 
<xsl:function name="functx:ordinal-number-en" as="xs:string" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="num" as="xs:integer?"/> 
 
  <xsl:sequence select=" 
   concat(xs:string($num),
         if (matches(xs:string($num),'[04-9]$|1[1-3]$')) then 'th'
         else if (ends-with(xs:string($num),'1')) then 'st'
         else if (ends-with(xs:string($num),'2')) then 'nd'
         else if (ends-with(xs:string($num),'3')) then 'rd'
         else '')
 "/>
   
</xsl:function>


<!--
  Pads an integer to a desired length by adding leading zeros 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_pad-integer-to-length.html 
 @param   $integerToPad the integer to pad 
 @param   $length the desired length 
--> 
<xsl:function name="functx:pad-integer-to-length" as="xs:string" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="integerToPad" as="xs:anyAtomicType?"/> 
  <xsl:param name="length" as="xs:integer"/> 
 
  <xsl:sequence select=" 
   if ($length &lt; string-length(string($integerToPad)))
   then error(xs:QName('functx:Integer_Longer_Than_Length'))
   else concat
         (functx:repeat-string(
            '0',$length - string-length(string($integerToPad))),
          string($integerToPad))
 "/>
   
</xsl:function>


<!--
  Pads a string to a desired length 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_pad-string-to-length.html 
 @param   $stringToPad the string to pad 
 @param   $padChar the character(s) to use as padding 
 @param   $length the desired length 
--> 
<xsl:function name="functx:pad-string-to-length" as="xs:string" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="stringToPad" as="xs:string?"/> 
  <xsl:param name="padChar" as="xs:string"/> 
  <xsl:param name="length" as="xs:integer"/> 
 
  <xsl:sequence select=" 
   substring(
     string-join (
       ($stringToPad, for $i in (1 to $length) return $padChar)
       ,'')
    ,1,$length)
 "/>
   
</xsl:function>


<!--
  A unique path to an XML node (or sequence of nodes) 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_path-to-node-with-pos.html 
 @param   $node the node sequence 
--> 
<xsl:function name="functx:path-to-node-with-pos" as="xs:string" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="node" as="node()?"/> 
 
 <xsl:variable name="names" as="xs:string*">
   <xsl:for-each select="$node/ancestor-or-self::*">
     <xsl:variable name="ancestor" select="."/>
     <xsl:variable name="sibsOfSameName"
           select="$ancestor/../*[name() = name($ancestor)]"/>
     <xsl:sequence select="concat(name($ancestor),
         if (count($sibsOfSameName) &lt;= 1)
         then ''
         else concat(
        '[',functx:index-of-node($sibsOfSameName,$ancestor),']'))"/>
   </xsl:for-each>
 </xsl:variable>
 <xsl:sequence select="string-join($names,'/')"/>
 
</xsl:function>


<!--
  A path to an XML node (or sequence of nodes) 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_path-to-node.html 
 @param   $nodes the node sequence 
--> 
<xsl:function name="functx:path-to-node" as="xs:string*" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="nodes" as="node()*"/> 
 
  <xsl:sequence select=" 
$nodes/string-join(ancestor-or-self::*/name(.), '/')
 "/>
   
</xsl:function>


<!--
  Whether an XML node precedes another without being its ancestor 

 @author  W3C XML Query Working Group 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_precedes-not-ancestor.html 
 @param   $a the first node 
 @param   $b the second node 
--> 
<xsl:function name="functx:precedes-not-ancestor" as="xs:boolean" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="a" as="node()?"/> 
  <xsl:param name="b" as="node()?"/> 
 
  <xsl:sequence select=" 
   $a &lt;&lt; $b and empty($a intersect $b/ancestor::node())
 "/>
   
</xsl:function>


<!--
  The previous day 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_previous-day.html 
 @param   $date the date 
--> 
<xsl:function name="functx:previous-day" as="xs:date?" 
              xmlns:functx="http://www.functx.com" >
  <xsl:param name="date" as="xs:anyAtomicType?"/> 
 
  <xsl:sequence select=" 
   xs:datd   ate) - xs:dayTimeDuration('P1D')
 "/>
   
</xsl:function>


<!--
  Removes attributes from an XML fragment, based on name 

 @author  Priscilla Walmsley, Datypic 
 @version 1.0 
 @see     http://www.xsltfunctions.com/xsl/functx_remove-attributes-deep.h select="
              (@*[not(functx:name-test(name(),$names))],
               functx:remove-attributes-deep(node(), $names))"/>
         </xsl:element>
       </xsl:when>
       <xsl:when test=". instance of document-node()">
         <xsl:document>
  