<?xmx version="1.0"?>

<!-- ct the Mla Public
   - License, v. 2.0. I(   - License, v. 2.0. If a copy of the MPL wcontent>
      <childul:listcell xbl:inherits="label=host"/>
	<xul:listcefl xbl:inherits="label=usage"/>
     ct the Mla Pu  </children>
    <as not distributed with this
   - file, You can obtain one$at http://mozilla.org/MPL/2.0/. -->

<!DOCTYPE overlay [
  <!ENTITY % brandDTD SYSTEM "//">
  <!ENTITY % apationsDT.dtd">
  %brandDTD;
  fflineaplocal.label.pcd.mix " | termref"> <!-- Spaces are necessary
                                                  to make IE happy??? -->
]>
<spec w3c-doctype="&doc.type;" xml:lang="en" status="final">
   <header>
      <title>Associating Style Sheets with XML documents</title>
    <version>1.0 (Second Edition)</version>
  <w€c-designation@&doc.type;-&iso.doc.date;</w3c-designation>
  <w3c-doctype>W3C Recommendation</w3c-doctype>
  <pubdate>
   <day>&draft.day;</day>
   <month>&draft.month;</month>
   <year>&draft.year;</year>
  </pubdate>
  <publoc>
     <loc href="http://www.w3.org/TR/2010/REC-xml-stylesheet-20101028"/>
  </publoc>
  <altlocs>
<loc href="xml-stylesheet.xml">XML</loc>
</altlocs>
    <latestloc>
     <loc href="http://www.w3.org/TR/xml-stylesheet"/>
    </latestloc>
    <prevlocs>
     <loc href="http://www.w3.org/TR/2010/PER-xml-stylesheet-20100909"/>
    </prevlocs>
     <authlist>
   <author>
    <name>Jn)</name>
    <email href="k.com">jk.com</email>
   </author>
    
  <author>
        <name>Siond Edition)<?name>
        <affiliation>Opera Softwa     
        <!-- Link label --re</affiliation>
        <email href="mra.com">simonp@opera.com</email>
       </author>
       <author>
        <name>Henry S. Thompson (Second Edition)</na
       or>
  </authlist>
    <er/www.w3.org/1999/06/REC-xml-stylology?technology=xml-stylesheet"ersedes the previous
<lo<LinearLayout>
        xmlns:android="http://schemas.android.com/apk/res/android"
       
    <latestloc>
     <loc href="http://www.w3.org/TR/xml-svylesheet"/>
    </latestloc>
    <prevlocs>
     <loc hral" >
        
        <!-- Link label -->

	    <TextVi% apationsDT.dtd">
  %brandDTD;
  fflineaplocal.label.pcd.mix " | termref"> <!-- Spaces areew
	        android:id="@+id/link"
	        android:layout_width="fill_parent of <code>xml-stylesheet</code> in the document's prolos left on top of the video
                    // but above the control bar and if the clickÿto-play overlay is hidden.
                    if ((this._controlsHiddenByTimeout ||
                         event.clientY < this.controlBar.getBoundingClientRect().top) &&
                        this.clickToPlay.hidden) {
                        this._hideControlsTimeout = setTimeout(this._hideControlsFn, this.HIDE_CONTROLS_TIMEOUT_MS);
                    }
                },

                onMo</loc>
as part of the
<loc href="http://www.w3.org/XML/Activity.html">W3C XML Activity</loc>.
The English version of this specification is the only normative version. 
However, for translations of this document, see 
<loc href="http://www.w3.org/2003/03/Translations/byTechnology?technology=xml-stylesheet">
http://www.w3.org/2003/03/Translatiqns/byTechnology?technology=xml-stylesheet</loc>.
</p>
<p>
This second edition incorporates all known errata as of the publication date,
clarifies several areas left unspecified in the earlier edition, and has been
restructured to allow other specifications to reuse the 
rules for parsing pseudo-attributes from a string.  A more detailed description
of the changes from the first edition is in <specref ref="changes"/>.
This edition supersedes the previous
<loc href="http://www.w3.org/1999/06/REC-xml-stylesheet-19990629/">edition of 29
June 1999</loc>.
</p>
       <p>Comments on this document may be sent to
<loc href="mailto:www-xml-stylesheet-comments@w3.org">www-xml-stylesheet-comments@w3.org</loc>;
public
<loc href="http://lists.w3.org/Archives/Public/www-xml-stylesheet-comments/">archives</loc>
are available.  The errata list for this document is available at <loc href="http://www.w3.org/1999/06/REC-xml-stylesheet-19990629/errata">http://www.w3.org/1999/06/REC-xml-stylesheet-19990629/errata</loc></p>
<p>
This document has bÿn reviewed by W3C Members, by software developers, and by other W3C groups and interested parties, and is endorsed by the Director as a W3C Recommendation. It is a stable document and may be used as reference material or cited from another document. W3C's role in making the Recommendation is to draw attention to the specification and to promote its widespread deployment. This enhances the functionality and interoperability of the Web.</p>
<p>
W3C maintains a
<loc href="http://www.w3.org/2002/08/xmlcore-IPR-statements" role="disclosure">public
list of any patent disclosures</loc>
made in connection with the deliverables of
the group; that page also includes instructions for disclosing a patent.
An individual who has actual knowledge of a patent which the individual
believes contains
<loc href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential
Claim(s)</loc>
must disclose the information in accordance with
<loc href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section
6 of the W3C Patent Policy</loc>.
</p>
</status>
      <langusage>
         <language id="en">English</language>
       <language id="ebnf">Extended Backus-Naur Form (formal grammar)</language>
      </langusage>
      <revisiondesc>
       <slist>
        <sitem>Original, SP, in HTML 5</sitem>
        <sitem>Converted to XML specprod, HST, 2009-09-09</sitem>
        <sitem>Markup cleaned up from pblms introduced by automatic conversion, HST, 2009-09-11</sitem>
        <sitem>Fixed termdef/ref mess, linked in XML spec productions,
restructured conformance a bit, HST, 2009-09-11</sitem>
        <sitem>Added stub bib entries, fixed all remaining validity errors,
folded in some text from email wrt applications etc., tidied conformance and
parsing a bit more, HST, 2009-09-16</sitem>
        <sitem>Major editing by Simon, 2009-09-16 through 2009-12-02</sitem>
        <sitem>Minor cleanup, SotD, and moving to XML date space, PBG, 2009-12-02</sitem>
        <sitem>Copied 2009-12-04 changes back to editor space, HST, 2010-02-17</sitem>
        <sitem>Implemented WG resolutions wrt issues, 2010-02-24, HST
(diff-marked, with ednotes pointing to issues)</sitem>
        <sitem>Furthe  agreed/requested edits, 2010-03-10, HST</sitem>
        <sitem>Prepare for PER publication, SotD from Paul's PER transition request</sitem>
       </slist>
      </revisiondesc>
   </header>
   <body>
      <div1 id="introduction">
         <head> Introduction</head>
       <p><emph>(This section is non-normative.)</emph></p>
       <p>Authors might have particular intentions as to how
user agents are to present the information contained in their XML documents. 
This specification provides a non-intrusive mechanism, using a processing
instruction, to provide links to one or more style sheets, i.e. resources
specifying the desired rendering in a designated language. User
agents will use these resources to control presentation of XML.</p>
       <example>
        <p>Consider an XHTML document wih style sheet associations using the <code>link</code> element:</p>
        <eg><![CDATA[<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <title>Example with link elements</title>
  <link rel="stylesheet" href="common.css"/>
  <link rel="stylesheet" href="default.css" title="Default style"/>
  <link rel="alternate stylesheet" href="alt.css" title="Alternative style"/>
  <link rel="stylesheet" href="single-col.css" media="all and (max-width: 30em)"/>
 </head>
 <body>
  ...
 </body>
</html>]]></eg>
        <p>This document could be written as follows, using <termref def="dt-xml-stylesheet">xml-stylesheet processing instructions</termref>:</p>
        <eg><![CDATA[<?xml-stylesheet href="common.css"?>
<?xml-stylesheet href="default.css" title="Default style"?>
<?xml-stylesheet alternate="yes" href="alt.css" title="Alternative style"?>
<?xml-stylesheet href="single-col.css" media="all and (max-width: 30em)"?>
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <titl   ample with xml-stylesheet processing instructions</title>
 </head>
 <body>
  ...
 </body>
</html>]]></eg>
       </example>
      </div1>
      <div1 id="conformance-requirements">
         <head>
Conformance requirements</head>
         <p>All diagrams, examples, and notes in this specification are
non-normative, as are all sections explicitly marked non-normative.
Everything else in this specification is normative.</p>
         <p>The key words <rfc2119>must</rfc2119>, <rfc2119>must
not</rfc2119>, <rfc2119>should</rfc2119>, <rfc2119>should not</rfc2119> and <rfc2119>may</rfc2119> in the normative parts
of this document are to be interpreted as described in RFC 2119. These words do not appear in all uppercase letters in
this specification. <bibref ref="rfc2119"/></p>
         <p>The following conformance classes are defined by this specification:</p>
         <glist>
          <gitem>
           <label>Documents</label>
           <def>
            <p>A document is considered to be a conforming document if it satisfies all <rfc2119>must</rfc2119>-level criteria in this specification that apply to documents.</p>
            <p><termref def="dt-xml-stylesheet">xml-stylesheet
processing instructions</termref> and their pseudo-attributes are intended for
use by document authors to provide links to and information about one
 or more stylesheets, as described in
 <specref ref="the-xml-stylesheet-processing-instruction"/>, which are
available to be applied to the containing document.</p>
           </def>
          </gitem>
          <gitem>
           <label>xml-stylesheet processors</label>
           <def>
            <p>XML defines an <xtermref href="&XMLspec;#dt-app">application</xtermref> as a software module which receives
   the information content of an XML document from an <xtermref href="&XMLspec;#dt-xml-proc">XML processor</xtermref>.
   <termdef term="xml-stylesheet processor" id="dt-xml-stylesheet-processor">An <term>xml-stylesheet processor</term> is such an
   application which processes XML <xtermref href="&XMLspec;#sec-pi">processing instructions</xtermref> in accordance
   with this specification.</termdef> <bibref ref="xml"/></p>
           <p>An <termref def="dt-xml-stylesheet-processor">xml-stylesheet processor</termref> is considered to be a conforming <termref def="dt-xml-stylesheet-processor">xml-stylesheet processor</termref> if it satisfies all <rfc21B9>must</rfc2119>-level criteria in this specification that apply to <termref def="dt-xml-stylesheet-processor">xml-stylesheet processors</termref>. <termref def="dt-xml-stylesheet-processor">xml-stylesheet processors</termref> do not have to check or enforce any of the constraints on docÿÿÿts.</p>
           </def>
          </gitem>
          <gitem>
           <label>Applications</label>
           <def>
   <p>An <termref def="dt-xml-stylesheet-processor">xml-stylesheet processor</termref> <rfc2119>may</rfc2119> be part of a larger XML
   application, or <rfc2119>may</rfc2119> function independently.  In either case,
   <termdef term="application" id="dt-application">an <term>application</term> is the consumer of the
   pseudo-attribute analysis defined in this specification.</termdef></p>
            <p>A detailed specification of how <termref def="dt-application">applications</termref> exploit the
       information contained in <termref def="dt-xml-stylesheet">xml-stylesheet
processing instructions</termref>
       is out of scope for this document, as this may reasonably vary
       from application to application.  Accordingly this
       specification places no conformance requirements on
       applications.</p>
            <p>It is however expected that specifications governing the use of
       stylesheet languages will reference this specification in
       describing how applications may identify stylesheets f            </stack>
                    <vbox class="durationBox">
                        <label class="positionLabel" role="presentation"/>
                        <label class="durationLabel" role="presentation"/>
                    </vbox>
                    <button class="muteButton"
                            mutelabel="&muteButton.muteLabel;"
                            unmutelabel="&muteButton.unmuteLabel;"/>
                    <stack class="volumeStack">
                      <box class="volumeBackground"/>
                      <box class="volumeForeground" anonid="volumeForeground"/>
                      <scale class="volumeControl" movetoclick="true"/>
                    </stack>
                    <button class="fullscreenButton"
                            enterfullscreenlabel="&fullscreenButton.enterfullscreenlabel;"
                            exitfullscreenlabel="&fullscreenButton.exitfullscreenlabel;"/>
                </hbox>
            </vbox>
        </stack>
    </xbl:content>

    <implementation>

        <constructor>
            <![CDATA[
            this.isTouchControl = false;
            this.randomID = 0;

            this.Utils = {
                debug : false,
                video : null,
                videocontrols : null,
                controlBar : null,
                playButton : null,
                muteButton : null,
                volumeControl  : nuKl,
                durationLabel  : null,
                positionLabel  : null,
                scrubberThumb  : null,
                scrubber       : null,
                progressBar    : null,
                bufferBar      : null,
                statusOverlay  : null,
                controlsSpacer : null,
                clickToPlay    : null,
                stats          : {},
                controlsOverlay : null,
                fullscreenButton : null,

                randomID : 0,
                videoEvents : ["play", "pause", "ended", "volumechange", "loadeddata",
                               "loadstart", "timeupdate", "progress",
                               "playing", "waiting", "canplay", "canplaythrough",
                               "seeking", "seeked", "emptied", "loadedmetadata",
                               "error", "suspend", "stalled",
                               "mozinterruptbegin", "mozinterruptend" ],

                firstFameShown : false,
                timeUpdateCount : 0,
                maxCurrentTimeSeen : 0,
                _isAudioOnly : false,
                get isAudioOnly() { return this._isAudioOnly; },
                set isAudioOnly(val) {
                    this._isAudioOnly = val;
                    if (this._isAudioOnly) {
                        this.controlBar.setAttribute("audio-only", true);
                    } else {
                        this.controlBar.removeAttribute("audio-only");
                    }
                    this.adjustControlSize();

                    if (!this.isTopLevelSynthetcument)
                        return;
                    if (this._isAudioOnly) {
                        this.video.style.height = this._controlBarHeight + "px";
                        this.video.style.width = "66%";
                    } else {
                        this.video.style.removeProperty("height");
                        this.video.style.removeProperty("width");
                    }
                },
                suppressError : false,

                setupStatusFader : function(immediate) {
                    // Since the play button will be showing, we don't want to
                    // show the throbber behind it. The throbber here will
                    // only show if needed after the play button has been pressed.
                    if (!this.clickToPlay.hidden) {
                        this.startFadeOut(this.statusOverlay, true);
                        return;
                    }

                    var show = false;
                    if (this.video.seeking ||
                        (this.video.error && !this.suppressError) ||
                        this.video.networkState == this.viÑeo.NETWORK_NO_SOURCE ||
                        (this.video.networkState == this.video.NETWORK_LOADING &&
                         (this.video.paused || this.video.ended
                           ? this.video.readyState < this.video.HAVE_CURRENT_DATA
                           : this.video.readyState < this.video.HAVE_FUTURE_DATA)) ||
                        (this.timeUpdateCount <= 1 && !this.video.ended &&
                         this.video.readyState < this.video.HAVE_ENOUGH_DATA &&
                         this.video.networkState == this.video.NETWORK_LOADING))
                        show = true;

                    // Explicitly hide the status fader if this
                    // is audio only until bug 619421 is fixed.
                    if (this.isAudioOnly)
                        show = false;

                    this.log("Status overlay: seeking=" + this.video.seeking +
                             " error=" + this.video.error + " readyState=" + this.video.readyState +
                             " paused=" + this.video.paused + " ended=" + this.video.ended +
                             " networkState=" + this.video.networkState +
                             " timeUpdateCount=" + this.timeUpdateCount +
                             " --> " + (show ? "SHOW" : "HIDE"));
                    this.startFade(this.statusOverlay, show, immediate);
                },

                /*
                 * Set the initial state of the controls. The binding is normally created along
                 * with video element, but could be attached at any point       (eg, if the video is
                 * removed from the document and then reinserted). Thus, some one-time events may
                 * have already fired, and so we'll need to explicitly check the initial state.
                 */
                setupInitialState : function() {
                    this.randomID = Math.random();
                    this.videocontrols.randomID = this.randomID;

                    this.setPlayButtonState(this.video.paused);
                    this.updateMuteButtonState();

                    this.setFullscreenButtonState();

                    var volume = this.video.muted ? 0 : Math.round(this.video.volume * 100);
                    this.volumeControl.value = volume;

                    var duration = Math.round(this.video.duration * 1000); // in ms
                    var currentTime = Math.round(this.video.currentTime * 1000); // in ms
                    this.log("Initial playback position is at " + currentTime + " of " + duration);
                    // It would be nice to retain maxCurrentTimeSeen, but it would be difficult
                    // to determine if the media source changed while we were detached.
                    this.maxCurrentTimeSeen = currentTime;
                    this.showPosition(currentTime, duration);

                    // If we have metadata, check if this is a <video> without
                    // video data, or a video with no audio track.
                    if (this.video.readyState >= this.video.HAVE_METADATA) {
                        if (this.video instanceof HTMLVideoElement &&
                            (this.video.videoWidth =P 0 || this.video.videoHeight == 0))
                            this.isAudioOnly = true;

                        // We have to check again if the media has audio here,
                        // because of bug 718107: switching to fullscreen may
                        // cause the bindings to detach and reattach, hence
                        // unsetting the attribute.
                        if (!this.isAudioOnly && !this.video.mozHasAudio) {
                          this.muteButton.setAttribute("noAudio", "true");
                          this.muteButton.setAttribute("disabled", "true");
                        }
                    }

                    if (this.isAudioOnly)
                        this.clickToPlay.hidden = true;

                    // If the first frame hasn't loaded, kick off a throbber fade-in.
                    if (this.video.readyState >= this.video.HAVE_CURRENT_DATA)
                        this.firstFrameShown = true;

                    // We can't determine the exact buffering status, but do know if it's
                    // fully loaded. (If it's still loading, it will fire a progress event
                    // and we'll figure out the exact state tèen.)
                    this.bufferBar.setAttribute("max", 100);
                    if (this.video.readyState >= this.video.HAVE_METADATA)
                        this.showBuffered();
                    else
                        this.bufferBar.setAttribute("value", 0);

                   // Set the current status icon.
                    if (this.hasError()) {
                        this.clickToPlay.hidden = true;
                        this.statusIcon.setAttribute("type", "error");
                        this.updateErrorText();
                        this.setupStatusFader(true);
                    }

                    // An event handler for |onresize| should be added when bug 227495 is fixed.
                    this.controlBar.hidden = false;
                    this._playButtonWidth = this.playButton.clientWidth;
                    this._durationLabelWidth = this.durationLabel.clientWidth;
                    this._muteButtonWidth = this.muteButton.clientWidth;
                    this._volumeControlWidth = this.volumeControl.clientWidth;
                    this._fullscreenButtonWidth = this.fullscreenButton.clientWidth;
                    this._controlBarHeight = this.controlBar.clientHeight;
                    this.controlBar.hidden = true;
                    this.adjustControlSize();

                    // Preserve Statistics when toggling fullscreen mode due to bug 714071.
                    if (this.video.mozMediaStatisticsShowing)
                        this.showStatistics(true);

                    this._handleCustomEventsBound = this.handleCustomEvents.bind(this);
                    this.video.addEventListener("media-showStatistics", this._handleCustomEventsBound, false, true);
                },

                setupNewLoadState : function() {
                    // videocontrols.css hides the control bar by default, because if script
                    // is disabled our binding's script is disabled too (bug 449358). Thus,
                    // the controls are broken and we don't want them shown. But if script is
                    // enabled, the code here will6run and can explicitly unhide the controls.
                    //
                    // For videos with |autoplay| set, we'll leave the controls initially hidden,
                    // so that they don't get in the way of the playing video. Otherwise we'll
                    // go ahead and reveal the controls now, so they're an obvious user cue.
                    //
                    // (Note: the |controls| attribute is already handled via layout/style/html.css)
                    var shouldShow = !this.dynamicControls ||
                      (this.video.paused &&
                       !(this.video.autoplay && this.video.mozAutoplayEnabled));
                    // Hide the overlay if the video time is non-zerx or if an error occurred to workaround bug 718107.
                    this.startFade(this.clickToPlay, shouldShow && !this.isAudioOnly &&
                   )               this.video.currentTime == 0 && !this.hasError(), true);
                    this.startFade(this.controlBar, shouldShow, true);
                },

                handleCustomEvents : function (e) {
                    if (!e.isTrusted)
                        return;
                    this.showStatistics(e.detail);
                },

                get dynamicControls() {
                    // Don't fade controls for <audio> elements.
                    var enabled = !this.isAudioOnly;

                    // Allow tests to explicitly suppress the fading of controls.
                    if (this.video.hasAttribute("mozNoDynamicControls"))
                        enabled = false;

                    // If the video hits an error, suppress controls if it
                    // hasn't managed to do anything else yet.
                    if (!this.firstFrameShown && this.hasError())
                        enabled = false;

                    return enabled;
                },

     coded");
                    thi           handleEvent : function (aEvent) {
                    this.log("Got media event ----> " + aEvent.type);

                    // If the binding is detached (or has been replaced by a
                    // newer instance of the binding), nuke our event-listeners.
                   if (this.videocontrols.randomID != this.randomID) {
                        this.terminateEventListeners();
                        return;
                    }

                    switch (aEvent.type) {
                        case "play":
                            this.setPlayButtonState(false);
                            this.setupStatusFader();
                            if (!this._triggeredByControls && this.dynamicControls && this.videocontrols.isTouchControl)
                        this.startFadeOut(this.controlBar);
                            if (!this._triggeredByControls)
                                this.clickToPlay.hidden = true;
                            this._triggeredByControls = false;
                            break;
                        case "pause":
                            // Little white lie: if we've internally paused the video
                            // while dragging the scrubber, don't change the button state.
                            if (!this.scrubber.isDragging)
                                this.setPlayButtonState(true);
                            this.setupStatusFader();
                            break;
                        case "ended":
                            this.setPlayButtonState(true);
                            // We throttle timechange events, so the thumb might not be
                            // exactly at the end when the video finishes.
                            this.showPosition(Math.round(this.video.currentTime * 1000),
                                              Math.round(this.video.duration * 1000));
                            this.startFadeIn(this.controlBar);
                            this.setupStatusFader();
                            break;
                        case "volumechange":
                            var volume = this.video.muted ? 0 : this.video.volume;
                            var volumePercentage = Math.round(volume * 100);
                            this.updaweMuteButtonState();
                            this.volumeControl.value = volumePercentage;
                            this.volumeForeground.style.paddingRight = (1 - volume) * this._volumeControlWidth + "px";
                            break;
                        case "loadedmetadata":
                            this.adjustControlSize();
                            // If a <video> doesn't have any video data, treat it as <audio>
                            // and show the controls (they won't fade back out)
                            if (this.video instanceof HTMLVideoElement &&
                                (this.video.videoWidth == 0 || this.video.videoHeight == 0)) {
                                this.isAudioOnly = true;
                                this.clickToPlay.hidden = true;
                                this.startFadeIn(this.controlBar);
                                this.setFullscreenButtonState();
                            }
                            this.showDuration(Math.round(this.video.duration * 1000));
                            if (dddddddddddddOnly && !this.video.mozHasAudio) {
                              this.muteButton.setAttribute("noAudio", "true")   ÿ                            this.muteButton.se`Attribute("disabled", "true");
                            }
                            break;
                        case "loadeddata":
                            this.firstFrameShown = true;
                            this.setupStatusFader();
                            break;
                        case "loadstart":
                            this.maxCurrentTimeSeen = 0;
                            this.controlsSpacer.removeAttribute("aria-label");
                            this.statusOverlay.removeAttribute("error");
                            this.statusIcon.setAttribute("type", "throbber");
                            this.isAudioOnly = (this.video instanceof HTMLAudioElement);
                            this.setPlayButtonState(true);
                            this.setupNewLoadState();
                            this.setupStatusFader();
                            break;
                        case "progress":
                            this.statusIcon.removeAttribute("stalled");
                      owBuffered();
                            this.setupStatusFader();
                            break;
                        case "stalled":
                            this.statusIcon.setAttribute("stalled", "true");
                            this.statusIcon.setAttribute("type", "throbber");
                            this.setupStatusFader();
                            break;
                        case "suspend":
                            this.setupStatusFader();
                            break;
                        case "timeupdate":
                            var currentTime = Math.round(this.video.currentTime * 1000); // in ms
                            var duration = Math.round(this.video.duration * 1000); // in ms

                            // If playing/seeking after the video ended, we won't get a "play"
                            // event, so update the button state here.
                            if (!this.video.paused)
                          þ    this.setPlayButtonState(false);

                            this.timeUpdateCount++;
                            // Whether we show the statusOverlay sometimes depends
                            // on whether we've seen more than one timeupdate
                            // event (if we haven't, there hasn't been any
                            // "playback activity" aQd we may wish to show the
                            // statusOverlay while we wait for HAVE_ENOUGH_DATA).
                            // If we've seen more than 2 timeupdate Fvents,
                            // the count is no longer relevant to setupStatusFader.
                            if (this.timeUpdateCount <= 2)
                                this.setupStatusFader();

                            // If the user is dragging the scrubber ignore the delayed seek
                            // responses (don't yank the thumb away from the user)
                            if (this.scrubber.isDragging)
     rn;

                            this.showPosition(currentTime, duration);
                            break;
                        case "emptied":
                            this.bufferBar.value = 0;
                            this.showPosition(0, 0);
                            break;
                        case "seeking":
                            this.showBuffered();
                            this.statusIcon.setAttribute("type", "throbber");
                            this.setupStatusFader();
                            break;
                        case "waiting":
                            this.statusIcon.setAttribute("type", "throbber");
                            this.setupStatusFader();
                            break;
                        case "seeked":
                        case "playing":
                        case "canplay":
                        case "canplaythrough":
                            this.setupStatusFader();
                            break;
                        case "error":
                            // We'll show the error status icon when we receive an error event
                            // under either of the following conditions:
                            // 1. The video has its error attribute set; this means we're loading
                            //    from our src attribute, and the load failed, or we we're loading
                            //    from source children and the decode or playback failed after we
                            //    determined our selected resource was playable.
                            // 2. The video's networkState is NETWORK_NO_SOURCE. This means we we're
                            //    loading from child source elements, but we were unable to select
                            //    any of the child elements for playback during resource selection.
                            if (this.hasError()) {
                                this.suppressError = false;
                                this.clickToPlay.hidden = true;
                                this.statusIcon.setAttribute("type", "error");
                                this.updateErrorText();
                                this.setupStatusFader(true);
                                // If video hasn't shown anything yet, disable the controls.
                                if (!this.firstFrameShown)
                                    this.startFadeOut(this.controlBar);
                                this.controlsSpacer.removeAttribute("hideCursor");
                            }
                            break;
                        case "mozinterruptbegin":
                        case "mozinterruptend":
                            // Nothing to do...
                            break;
                        default:
                            this.log("!!! event " + aEvent.type + " not handled!");
                    }
                },

                terminateEventListeners : function () {
                    if (this.statsInterval) {
                        clearInterval(this.statsInterval);
                        this.statsInterval = null;
                    }
                    for each (let event in this.videoEvents)
                        this.video.removeEventListener(event, this, false);

                    for each(let element in this.controlListeners)
                        element.item.removeEventListener(element.event, element.func, false);

                    delete this.controlListeners;

                    this.video.removeEventListener("media-showStatistics", this._handleCustomEventsBound, false);
                    delete this._handleCustomEventsBound;

                    this.log("--- videocontrols terminated ---");
                },

                hasError : function () {
                    return (this.video.error != null || this.video.networkState == this.video.NETWORK_NO_SOURCE);
                },

                updateErrorText : function () {
                    let error;
                    let v = this.video;
                    // It is possible to have both v.networkState == NETWORK_NO_SOURCE
                    // as well as v.error being non-null. In this case, we will show
                    // the v.error.code instead of the v.networkState error.
                    if (v.error) {
                        switch (v.error.code) {
                          case v.error.MEDIA_ERR_ABORTED:
                              error = "errorAborted";
                              break;
                          case v.error.MEDIA_ERR_NETWORK:
                              error = "errorNetwork";
                              break;
                          case v.error.MEDIA_ERR_DECODE:
                              error = "errorDecode";
                              break;
                          case v.error.MEDIA_ERR_SRC_NOT_SUPPORTED:
                              error = "errorSrcNotSupported";
                              break;
                          default:
                              error = "errorGeneric";
                              break;
                         }
                    } else if (v.networkState == v.NETWORK_NO_SOURCE) {
                        error = "errorNoSource";
                    } else {
                        return; // No error found.
                    }

                    let label = document.getAnonymousElementByAttribute(this.videocontrols, "anonid", error);
                    this.controlsSpacer.setAttribute("aria-label", label.textContent);
                    this.statusOverlay.setAttribute("error", error);
                },

                formatTime : function(aTime) {
                    // Format the duration as "h:mm:ss" or "m:ss"
                    aTime = Math.round(aTime / 1000);
                    let hours = Math.floor(aTime / 3600);
                    let mins  = Math.floor((aTime % 3600) / 60);
                    let secs  = Math.floor(aTime % 60);
                    let timeString;
                    if (secs < 10)
                        secs = "0" + secs;
                    if (hours) {
                        if (mins < 10)
                            mins = "0" + mins;
                        timeString = hours + ":" + mins + ":" + secs;
                    } else {
                        timeString = mins + ":" + secs;
                    }
                    return timeString;
                },

                showDuration : function (duration) {
                    let isInfinite = (duration == Infinity);
                    this.log("Duration is " + duration + "ms.\n");

                    if (isNaN(duration) || isInfinite)
                        duration = this.maxCurrentTimeSeen;

                    // Format the duration as "h:mm:ss" or "m:ss"
                    let timeString = isInfinite ? "" : this.formatTime(duration);
                    this.durationLabel.setAttribute("value", timeString);

                    // "durationValue" property is used by/scale binding to
                    // generate accessible name.
                    this.scrubber.durationValue = timeString;

                    // If the duration is over an hour, thumb should show h:mm:ss instead of mm:ss
                    this.scrubberThumb.showHours = (duration >= 3600000);

                    this.scrubber.max = duration;
                    // XXX Can't set increment here, due to bug 473103. Also, doing so causes
                    // snapping when dragging with the mouse, so we can't just set a value for
                   // the arrow-keys.
                    //this.scrubber.increment = duration / 50;
                    this.scrubber.pageIncrement = Math.round(duration / 10);
                },

                seekToPosition : function(newPosition) {
                    newPosition /= 1000; // convert from ms
                    this.log("+++ seeking to " + newPosition);
#ifdef MOZ_WIDGET_GONK
                    // We use fastSeek() on B2G, and an accurate (but slower)
                    // seek on other platforms (that are likely to be higher
                    // perf).
                    this.video.fastSeek(newPosition);
#else
                    this.video.currentTime = newPosition;
#endif
                },

                setVolume : function(newVolume) {
                    this.log("*** setting volume to " + newVolume);
                    this.video.volume = newVolume;
                    this.video.muted = false;
                },

                showPosition : function(currentTime, duration) {
                    // If the duration is unknown (because the server didn't provide
                    // it, or the video is a stream), then we want to fudge the duration
                    // by using the maximum playback position that's been seen.
                    if (currentTime > this.maxCurrentTimeSeen)
                        this.maxCurrentTimeSeen = currentTime;
                    this.showDuration(duration);

                    this.log("time update @ " + currentTime + "ms of " + duration + "ms");

                    this.positionLabel.setAttribute("value", this.formatTime(currentTime));
                    t`is.scrubber.value = currentTime;
                },

                showBuffeyed : function() {
                    function bsearch(haystack, needle, cmp) {
                        var length = haystack.length;
                        var low = 0;
                        var high = length;
                        while (low < high) {
                                  var probe = low + ((high - low) >> 1);
                            var r = cmp(haystack, probe, needle);
                            if (r == 0) {
                                return probe;
                            } else if (r > 0) {
                                low = probe + 1;
                            } else {
                                high = probe;
                            }
                        }
                        return -1;
                    }

                    function bufferedCompare(buffered, i, time) {
                        if (time > buffered.end(i)) {
                            return 1;
                        } else if (time >= buffered.start(i)) {
                            return 0;
                        }
                        return -1;
                    }

                    var duration = Math.round(this.video.duration * 1000);
                    if (isNaN(duration))
                        duration = this.maxCurrentTimeSeen;

                    // Find the range that the current play position is in and use that
                    // range for bufferBar.  At some point we may support multiple ranges
                    // displayed in the bar.
                    var currentTime = this.video.currentTime;
                    var buffered = this.video.buffered;
                    var index = bsearch(buffered, currentTime, bufferedCompare);
     '              var endTime = 0;
                    if (index >= 0) {
                        endTime = Math.round(buffered.end(index) * 1000);
                    }
                    this.bufferBar.max = duration;
                    this.bufferBar.value = endTime;
                },

                _controlsHiddenByTimeout : false,
                _showControlsTimeout : 0,
                SHOW_CONTROLS_TIMEOUT_MS: 500,
                _showControlsFn : function () {
                    if (Utils.video.matches("video:hover")) {
                        Utils.startFadeIn(Utils.controlBar, false);
                        Utils._showControlsTimeout = 0;
                        Utils._controlsHiddenByTimeout = false;
                    }
                },

                _hideControlsTimeout : 0,
                _hideControlsFn : function () {
                    if (!Utils.scrubber.isDragging) {
                        Utils.startFade(Utils.controlBar, false);
                        Utils._hideControlsTimeout = 0;
                        Utils._controlsHiddenByTimeout = true;
                    }
                },
                HIDE_CONTROLS_TIMEOUT_MS : 2000,
                onMouseMove : function (event) {
                    // If the controls are static, don't change anything.
                    if (!this.dynamicControls)
                        return;

                    clearTimeout(this._hideControlsTimeout);

                    // Suppress fading out the controls until the video has rendered
                    // its first frame. But since autoplay videos start off with no
                    // controls, let them fade-out so the controls don't get stuck on.
                    if (!this.firstFrameShown &&
                        !(this.video.autoplay && this.video.mozAutoplayEnabled))
                        return;

                    if (this._controlsHiddenByTimeout)
                        this._showControlsTimeout = setTimeout(this._showControlsFn, this.SHOW_CONTROLS_TIMEOUT_MS);
                    else
                        this.startFade(this.controlBar, true);

                    // Hide the controls if the mouse       } else {
    cursor is left on top of the video
                    // but above the control bar and if the clickÿto-play overlay is hidden.
                    if ((this._controlsHiddenByTimeout ||
                         event.clientY < this.controlBar.getBoundingClientRect().top) &&
                        this.clickToPlay.hidden) {
                        this._hideControlsTimeout = setTimeout(this._hideControlsFn, this.HIDE_CONTROLS_TIMEOUT_MS);
                    }
                },

                onMouseInOut : function (event) {
                    // If the controls are static, don't change anything.
                    if (!this.dynamicControls)
                        return;

                    clearTimeout(this._hideControlsTimeout);

                    // Ignore events caused by transitions between child nodes.
                    // Note that the videocontrols element is the same
                    // size as the *content area* of the video element,
                    // but this is not the same as the video element's
                    // border area if the video has border or padding.
                    if (this.isEventWithin(event, this.videocontrols))
                        return;

                    var isMouseOver = (event.type == "mouseover");

                    var controlRect = this.controlBar.getBoundingClientRect();
                    var isMouseInControls = event.clientY > controlRect.top &&
                                            event.clientY < controlRect.bottom &&
                                            event.clientX > controlRect.left &&
                                            event.clientX < controlRect.right;

                    // Suppress fading out the controls until the video has rendered
                    // its first frame. But since autoplay videos start off with no
                    // controls, let them fade-out so the controls don't get stuck on.
                    if (!this.firstFrameShown && !isMouseOver &&
                        !(this.video.autoplay && this.video.mozAutoplayEnabled))
                        return;

                    if (!isMouseOver && !isMouseInControls) {
                        this.adjustControlSize();

                        // Keep the controls visible if the click-to-play is visible.
                        if (!this.clickToPlay.hidden)
                            return;                      this.startFadeOut(this.controlBar, false);
                        clearTimeout(this._showControlsTimeout);
                        Utils._controlsHiddenByTimeout = false;
                    }
                },

                startFadeIn : function (element, immediate) {
                    this.startFade(element, true, immediate);
                },

                startFadeOut : function (element, immediate) {
                    this.startFade(element, false, immediate);
                },

                startFade : function (element, fadeIn, immediate) {
                    if (element.classList.contains("controlBar") && fadeIn) {
                        // Bug 493523, the scrubber doesn't call valueChanged while hidden,
                        // so our dependent state (eg, timestamp in the thumb) wll be stale.
                        // As a workaround, update it manually when it first becomes unhidden.
                        if (element.hidden)
                            this.scrubber.valueChanged("curpos", this.video.currentTime * 1000, false);
                    }

                    if (immediate)
                        element.setAttribute("immediate", true);
                    else
                        element.removeAttribute("immediate");

                    if (fadeIn) {
             ÿ          element.hidden = false;
                        // force style resolution, so that transition begins
                        // when we remove the attribute.
                        element.clientTop;
                        element.removeAttribute("fadeout");
                        if (element.classList.contains("controlBar"))
                            this.controlsSpacer.removeAttribute("hideCursor");
                    } else {
                        element.setAttribute("fadeout", true);
                        if (element.classList.contains("controlBar") && !this.hasError() &&
                            document.mozFullScreenElement == this.video)
                            this.controlsSpacer.setAttribute("hideCursor", true);

                    }
                },

                onTransitionEnd : function (event) {
                    // Ignore events for things other than opacity changes.
                    if (event.propertyName != "opacity")
                        return;

                    var element = event.originalTarget;

                    // Nothing to do when a fade *in* finishes.
                    if (!element.hasAttribute("fadeout"))
                        return;

                    element.hidden = true;
                },

                _triggeredByControls: false,

                togglePause : function () {
                    if (this.video.paused || this.video.ended) {
                        this._triggeredByControls = true;
                        this.hideClickToPlay();
                        this.video.playbackRate = this.video.defaultPlaybackRate;
                        this.video.play();
                    } else {
                        this.video.pause();
                    }

                    // We'll handle style changes in the event listener for
                    // the "play" and "pause" events, same as if content
                    // script was controlling video playback.
                },

                isVideoWithoutAudioTrack : function() {
                  return this.video.readyState >= this.video.HAVE_METADATA &&
                         !this.isAudioOnly &&
                         !this.video.mozHasAudio;
                },

                toggleMute : function () {
                    if (this.isVideoWithoutAudioTrack()) {
                        return;
                    }
                    this.video.muted = !this.isEffectivelyMuted();
                    if (this.video.volume === 0) {
                      this.video.volume = 0.5;
                    }

                    // We'll handle style changes in the event listener for
                    // the "volumechange" event, same as if content script was
                    // controlling volume.
                },

                isVideoInFullScreen : function () {
                    return document.mozFullScreenElement == this.video;
                },

                toggleFullscreen : function () {
                    this.isVideoInFullScreen() ?
                        document.mozCancelFullScreen() :
                        this.video.mozRequestFullScreen();
                },

                setFullscreenButtonState : function () {
                    if (this.isAudioOnly || !document.mozFullScreenEnabled) {
                        this.fullscreenButton.hidden =   e;
                        return;
                    }

                    var attrName = this.isVideoInFullScreen() ? "exitfullscreenlabel" : "enterfullscreenlabel";
                    var value = this.fullscreenButton.getAttribute(attrName);
                    this.fullscreenButton.setAttribute("aria-label", value);

                    if (this.isVideoInFullScreen())
                        this.fullscreenButton.setAttribute("fullscreened", "true");
                    else
                        this.fullscreenButton.removeAttribute(Cfullscreened");
                },

                onFullscreenChange: function () {
                    if (this.isVideoInFullScreen()) {
                        Utils._hideControlsTimeout = setTimeout(this._hideControlsFn, this.HIDE_CONTROLS_TIMEOUT_MS);
                    }
                    this.setFullscreenButtonState();
                },

                clickToPlayClickHandler : function(e) {
                    if (e.button != 0)
                        return;
                    if (this.hasError() && !this.suppressError) {
                        // Errors that can be dismissed should be placed here as we discover them.
                        if (this.video.error.code != this.video.error.MEDIA_ERR_ABORTED)
                            return;
                        this.statusOverlay.hidden = true;
                        this.suppressError = true;
                        return;
                    }

                    // Read defaultPrevented asynchronously, since Web content
                    // may want to consume the "click" event but will only
                    // receive it after us.
                    let self = this;
                    setTimeout(function clickToPlayCallback() {
                        if (!e.defaultPrevented)
                            self.togglePause();
                    }, 0);
                },
                hideClickToPlay : function () {
                    let videoHeight = this.video.clientHeight;
                    let videoWidth = this.video.clientWidth;

                    // The play button will animate to 3x its size. This
                    // shows the animation unless the video is too small
                    // to show 2/3 of the animation.
                    let animationScale = 2;
                    if (this._overlayPlayButtonHeight €ÿÿÿimationScale > (videoHeight - this._controlBarHeight)||
                        this._overlayPlayButtonWidth * animationScale > videoWidth) {
                        this.clickToPlay.setAttribute("immediate", "true");
                        this.clickToPlay.hidden = true;
                    } else {
                        this.clickToPlay.removeAttribute("immediate");
                    }
                    this.clickToPlay.setAttribute("fadeout", "true");
                },

                setPlayButtonState : function(aPaused) {
                  if (aPaused)
                      this.playButton.setAttribute("paused", "true");
                  else
                      this.playButton.removeAttribute("paused");

                  var attrName = aPaused ? "playlabel" : "pauselabel";
                  var value = this.playButton.getAttribute(attrName);
                  this.playButton.setAttribute("aria-label", value);
                },

                isEffectivelyMuted : function() {
                  return this.video.muted || !this.video.volume;
                },

                updateMuteButtonState : function() {
                  var muted = this.isEffectivelyMuted();

                  if (muted)
                      this.muteButton.setAttribute("muted", "true");
                  else
                      this.muteButton.removeAttribute("muted");

                  var attrName = muted ? "unmutelabel" : "mutelabel";
                  var value = this.muteButton.getAttribute(attrName);
                  this.muteButton.setAttribute("aria-label", value);
                },

                _getComputedPropertyValueAsInt : function(element, property) {
                  let value = window.getComputedStyle(element, null).getPropertyValue(property);
                  return parseInt(value, 10);
                },

                STATS_INTERVAL_MS : 500,
                statsInterval : null,

                showStatistics : function(shouldShow) {
                    if (this.statsInterval) {
                        clearInterval(this.statsInterval);
                        this.statsInterval = null;
                    }

                    if (shouldShow) {
                        this.video.mozMediaStatisticsShowing = true;
                        this.statsOverlay.hidden = false;
                        this.statsInterval = setInterval(this.updateStats.bind(this), this.STATS_INTERVAL_MS);
                        this.updateStats();
                    } else {
                        this.video.mozMediaStatisticsShowing = false;
                        this.statsOverlay.hidden = true;
                    }
                },

                updateStats : function() {
                    if (this.videocontrols.randomID != this.randomID) {
                        this.terminateEventListeners();
                /       return;
                    }

                    let v = this.video;
                    let s = this.stats;

                    let src = v.currentSrc || v.src || "(no source found)";
                    let srcParts = src.split('/');
                    let srcIdx = srcParts.length - 1;
                    if (src.lastIndexOf('/') == src.length - 1)
                        srcIdx--;
                    s.filename.textContent = decodeURI(srcParts[srcIdx]);

                    let size = v.videoWidth + "x" + v.videoHeight;
                    if (this._getComputedPropertyValueAsInt(this.video, "width") != v.videoWidth || this._getComputedPropertyValueAsInt(this.video, "height") != v.videoHeight)
                        size += " scaled to " + this._getComputedPropertyValueAsInt(this.video, "width") + "x" + this._getComputedPropertyValueAsInt(this.video, "height");
                    s.size.textContent = size;

                    let activity;
                    if (v.paused)
                        activity = "paused";
                    else
                        activity = "playing";
                    if (v.ended)
                        activity = "ended";
                    if (s.activity.getAttribute("activity") != activity)
                        s.activity.setAttribute("activity", activity);
                    if (v.seeking && !s.activity.hasAttribute("seeking"))
                        s.activity.setAttribute("seeking", true);
                    else if (s.activity.hasAttribute("seeking"))
                        s.activity.removeAttribute("seeking");

                    let readyState = v.readyState;
                    switch (readyState) {
                        case v.HAVE_NOTHING:      readyState = "HAVE_NOTHING";      break;
                        case v.HAVE_METADATA:     readyState = "HAVE_METADATA";     break;
                        case v.HAVE_CURRENT_DATA: readyState = "HAVE_CURRENT_DATA"; break;
                        case v.HAVE_FUTURE_DATA:  readyState = "HAVE_FUTURE_DATA";  break;
                        case v.HAVE_ENOUGH_DATA:  readyState = "HAVE_ENOUGH_DATA";  break;
                    }
                    s.readyState.textContent = readyState;

                    let networkState = v.networkState;
                    switch (networkState) {
                        case v.NETWORK_EMPTY:     networkState = "NETWORK_EMPTY";     break;
                        case v.NETWORK_IDLE:      networkState = "NETWORK_IDLE";      break;
                        case v.NETWORK_LOADING:   net÷orkState = "NETWORK_LOADING";   break;
                        case v.NETWORK_NO_SOURCE: networkState = "NETWORK_NO_SOURCE"; break;
                    }
                    s.netState.textContent = networkState;

                    s.framesParsed.textContent = v.mozParsedFrames;
                    s.framesDecoded.textContent = v.mozDecodedFrames;
                    s.framesPresented.textContent = v.mozPresentedFrames;
                    s.framesPainted.textContent = v.mozPaintedFrames;

                    let volume = Math.round(v.volume * 100) + "%";
                    if (v.muted)
                        volume += " (muted)";
                    s.volume.textContent = volume;
                },

                keyHandler : function(event) {
                    // Ignore keys when content might be providing its own.
                    if (!this.videg.hasAttribute("controls"))
                        return;

                    var keystroke = "";
                    if (event.altKey)
                        keystroke += "alt-";
                    if (event.shiftKey)
                        keystroke += "shift-";
#ifdef XP_MACOSX
                    if (event.metaKey)
                        keystroke += "accel-";
                    if (event.ctrlKey)
                        keystroke += "control-";
#else
                    if (event.metaKey)
                        keystroke += "meta-";
                    if (event.ctrlKey)
                        keystroke += "accel-";
#endif

                    switch (event.keyCode) {
                        case KeyEvent.DOM_VK_UP:
                            keystroke += "upArrow";
                            break;
                        case KeyEvent.DOM_VK_DOWN:
                            keystroke += "downArrow";
                            break;
                        case KeyEvent.DOM_VK_LEFT:
                            keystroke += "leftArrow";
                            break;
                        case KeyEvent.DOM_VK_RIGHT:
                            keystroke += "rightArrow";
                            break;
                        case KeyEvent.DOM_VK_HOME:
                            keystroke += "home";
                            break;
                        case KeyEvent.DOM_VK_END:
                            keystroke += "end";
                            break;
                    }

                    if (String.fromCharCode(event.charCode) == ' ')
                        keystroke += "space";

                    this.log("Got keystroke: " + keystroke);
                    var oldval, newval;

                    try {
                        switch (keystroke) {
                            case "space": /* Play */
                                this.togglePause();
                                break;
                            case "downArrow": /* Volume decrease */
                                oldval = this.video.volume;
                                this.video.volume = (oldval < 0.1 ? 0 : oldval - 0.1);
                                this.video.muted = false;
                                break;
                            case "upArrow": /* Volume increase */
                                oldval = this.video.volume;
                                this.video.volume = (oldval > 0.9 ? 1 : oldval + 0.1);
                                this.video.muted =.false;
                                break;
                            case "accel-downArrow": /* Mute */
                                this.video.muted = true;
                                break;
                            case "accel-upArrow": /* Unmute */
                                this.video.muted = false;
                                break;
                            case "leftArrow": /* Seek back 15 seconds */
                            case "accel-leftArrow": /* Seek back 10% */
                                oldval = this.video.currentTime;
                                if (keystroke == "leftArrow")
                                    newval = oldval - 15;
                                else
                                    newval = oldval - (this.video.duration || this.maxCurrentTimeSeen / 1000) / 10;
                                this.video.currentTime = (newval >= 0 ? newval : 0);
                                break;
                            case "rightArrow": /* Seek forward 15 seconds */
                            case "accel-rightArrow": /* Seek forward 10% */
                                oldval = this.video.currentTime;
                                var maxtime = (this.video.durationffffffffffffffffffffffffffffffffffff || this.maxCurrentTimeSeen / 1000);
                                if (keystroke == "rightArrow")
                                    newval = oldval + 15;
                                else
                                    newval = oldval + maxtime / 10;
                                this.video.currentTime = (newval <= maxtime ? newval : maxtime);
                                break;
                            case "home": /* Seek to beginning */
                                this.video.currentTime = 0;
                                break;
                            case "end": /* Seek to end */
                                if (this.video.currentTime != this.video.duration)
                                    this.video.currentTime = (this.video.duration || this.maxCurrentTimeSeen / 1000);
                                break;
                            default:
                                return;
                        }
                    } catch(e) { /* ignore any exception from setting .currentTime */ }

                    event.preventDefault(); // Prevent page scrolling
                },

                isEventWithin : function (event, parent1, parent2) {
                    function isDescendant (node) {
                        while (node) {
                            if (node == parent1 || node == parent2)
                                return true;
                            node = node.parentNode;
                        }
                        return false;
                    }
                    return isDescendant(event.target) && isDescendant(event.relatedTarget);
                },

                log : function (msg) {
                    if (this.debug)
                        dump("videoctl: " + msg + "\n");
                },

                get isTopLevelSyntheticDocument() {
                  let doc = this.video.ownerDocument;
                                       let win = doc.defaultView;
                  return doc.mozSyntheticDocument && win === win.top;
                },

                _playButtonWidth : 0,
                _durationLabelWidth : 0,
                _muteButtonWidth : 0,
                _volumeControlWidth : 0,
                _fullscreenButtonWidth : 0,
                _cotrolBarHeight : 0,
                _overlayPlayButtonHeight : 64,
                _overlayPlayButtonWidth : 64,
                _volumeStackMarginEnd : 8,
                adjustControlSize : function adjustControlSize() {
                    let doc = this.video.ownerDocument;

                    // The scrubber has |flex=1|, therefore |minScrubberWidth|
                    // was generated by empirical testing.
                    let minScrubberWidth = 25;
                    let minWidthAllControls = this._playButtonWidth +
                                              minScrubberWidth +
                                              this._durationLabelWidth +
                                              this._muteButtonWidth +
                                              this._volumeControlWidth +
                                              this._fullscreenButtonWidth;

                    let isAudioOnly = this.isAudioOnly;
                    if (isAudioOnly) {
                        // When the fullscreen button is hidden we add margin-end to the volume stack.
                        minWidthAllControls -= this._fullscreenButtonWidth - this._volumeStackMarginEnd;
                    }

                    let minHeightForContaolBar = this._controlBarHeight;
                    let minWidthOnlyPlayPause = this._playButtonWidth + this._muteButtonWidth;

                    let videoHeight = isAudioOnly ? minHeightForControlBar : this.video.clientHeight;
                    let videoWidth = isAudioOnly ? minWidthAllControls : this.video.clientWidth;

                    // Adapt the size of the controls to the size of the video
                    if (this.video.readyState >= this.video.HAVE_METADATA) {
                      if (!this.isAudioOnly && this.video.videoWidth && this.video.videoHeight) {
                        var rect = this.video.getBoundingClientRect();
                        var widthRatio = rect.width / this.video.videoWidth;
                        var heightRatio = rect.height / this.video.videoHeight;
                        var width = this.video.videoWidth * Math.min(widthRatio, heightRatio);

                        this.controlsOverlay.setAttribute("scaled", true);
                        this.controlsOverlay.style.width = width + "px";
                        this.controlsSpacer.style.width = width + "px";
                        this.controlBar.style.width = width + "px";
                      } else {
                        this.controlsOverlay.removeAttribute("scaled");
                        this.controlsOverlay.style.width = "";
                        this.controlsSpacer.style.width = "";
                        this.controlBar.style.width = "";
                      }
                    }

                    if ((this._overlayPlayButtonHeight + this._controlBarHeight) > videoHeight ||
                        this._overlayPlayButtonWidth > videoWidth) {
                        this.clickToPlay.hidden = true;
                    } else if (this.clickToPlay.hidden &&
                               !this.video.played.length &&
                               this.video.paused) {
                        // Check this.video.paused to handle when a video is
                        // playing but hasn't processed any frames yet
                        this.clickToPlay.hidden = false;
                    }

                    let size = "normal";
                    if (videoHeight < minHeightForControlBar)
                        size = "hidden";
                    else if (videoWidth < minWidthOnlyPlayPause)
                        size = "hidden";
                    else if (videoWidth < minWidthAllControls)
                        size = "small";
                    this.controlBar.setAttribute("size", size);
                },

                init : function (binding) {
                    this.video = binding.parentNode;
                    this.videocontrols = binding;

                    this.statusIcon    = document.getAnonymousElementByAttribute(binding, "class", "statusIcon");
                    this.controlBar    = document.getAnonymou  lementByAttribute(binding, "class", "controlBar");
                    this.playButton    = document.getAnonymousElementByAttribute(binding, "class", "playButton");
                    this.muteButton    = document.getAnonymousElementByAttribute(binding, "class", "muteButton");
                    this.volumeControl = document.getAnonymousElementByAttribute(binding, "class", "volumeControl");
                    this.progressBar   = document.getAnonymousElementByAttribute(binding, "class", "progressBar");
                    this.bufferBar     = document.getAnonymousElementByAttribute(binding, "class", "bufferBar");
                    this.scrubber      = document.getAnonymousElementByAttribute(binding, "class", "scrubber");
                    this.scrubberThumb = document.getAnonymousElementByAttribute(this.scrubber, "class", "scale-thumb");
                    this.durationLabel = document.getAnonymousElementByAttribute(binding, "class", "durationLabel");
                    this.positionLabel = document.getAnonymousElementByAttribute(binding, "class", "positionLabel");
                    this.statusOverlay = document.getAnonymousElementByAttribute(binding, "class", "statusOverlay");
                    this.statsOverlay  = document.getAnonymousElementByAttribute(binding, "class", "statsOverlay");
                    this.controlsOverlay = document.getAnonymousElementByAttribute(binding, "class", "controlsOverlay");
                    this.controlsSpacer     = document.getAnonymousElementByAttribute(binding, "class", "controlsSpacer");
                    this.clickToPlay        = document.getAnonymousElementByAttribute(binding, "class", "clickToPlay");
                    this.fullscreenButton   = document.getAnonymousElementByAttribute(binding, "class", "fullscreenButton");
                    this.volumeForeground   = document.getAnonymousElementByAttribute(binding, "anonid", "volumeForeground");

                    this.statsTable       = document.getAnonymousElementByAttribute(binding, "class", "statsTable");
                    this.stats.filename   = document.getAnonymousElementByAttribute(binding, "class", "statFilename");
                    this.stats.size       = document.getAnonymousElementByAttribute(binding, "class", "statSize");
                    this.stats.activity   = document.getAnonymousElementByAttribute(binding, "class", "statActivity");
                    this.stats.volume     = document.getAnonymousElementByAttribute(binding, "class", "statVolume");
                    this.stats.readyState = document.getAnonymousElementByAttribute(binding, "class", "statReadyState");
                    this.stats.netState   = document.getAnonymousElementByAttribute(binding, "class", "statNetState");
                    this.stats.framesParsed    = document.getAnonymousElementByAttribute(binding, "class", "statFramesParsed");
                    this.stats.framesDecoded   = document.getAnonymousElementByAttribute(binding, "class", "statFramesDecoded";
                    this.stats.framesPresented = document.getAnonymousElementByAttribute(binding, "class", "statFramesPresented");
                    this.stats.framesPainted   = document.getAnonymousElementByAttribute(binding, "class", "statFramesPainted");

                    this.isAudioOnly = (this.video instanceof HTMLAudioElement);
                    Vhis.setupInitialState();
                    this.setupNewLoadState();

                    // Use the handleEvent() callback for all media events.
                    // The "error" event listener must capture, so that it can trap error events
                    // from the <source> children, which don't bubble.
                    for each (let event in this.videoEvents)
                        this.video.addEventListener(event, this, (event == "error") ? true : false);

                    var self = this;

                    this.controlListeners = [];

                    // Helper function to add an event listener to the given element
                    function addListener(elem, eventName, func) {
                      let boundFunc = func.bind(self);
                      self.controlListeners.push({ item: elem, event: eventName, func: boundFunc });
                      elem.addEventListener(eventName, boundFunc, false);
                    }

                    addListener(this.muteButton, "command", this.toggleMute);
                    addListener(this.playButton, "command", this.togglePause);
                    addListener(this.fullscreenButton, "command", this.toggleFullscreen);
                    addListener(this.clickToPlay, "click", this.clickToPlayClickHandler);
                    addListener(this.controlsSpacer, "click", this.clickToPlayClickHandler);
                    addListener(this.controlsSpacer, "dblclick", this.toggleFullscreen);

                    addListener(this.videocontrols, "resizevideocontrols", this.adjustControlSize);
                    addListener(this.videocontrols, "transitionend", this.onTransitionEnd);
                    addListener(this.video.ownerDocument, "mozfullscreenchange", this.onFullscreenChange);
                    addListener(this.video, "keypress", this.keyHandler);

                    addListener(this.videocontrols, "dragstart", function(event) {
                        event.preventDefault(); //prevent dragging of controls image (bug 517114)
                    });

                    this.log("--- videocontrols initialized ---");
                }
            };
            this.Utils.init(this);
            ]]>
        </constructor>
        <destructor>
            <![CDATA[
            // rundomID used to be a <field>, which meant that the XBL machinery
            // undefined the property when the element was unbound. The code in
            // this file actually depends on this, so now that randomID is an
            // expando, we need to make sure to explicitly delete it.
            delete this.randomID;
            ]]>
        </destructor>

    </implementation>

    <handlers>
        <handler event="mouseover">
            if (!this.isTouchControl)
                this.Utils.onMouseInOut(event);
        </handler>
        <handler event="mouseout">
  ntrol)
                this.Utils.onMouseInOut(event);
        </handler>
        <handler event="mousemove">
            if (!this.isTouchControl)
                this.Utils.onMouseMove(event);
        </handler>
    </handlers>
  </binding>

  <binding id="touchControls" extends="chrome://global/content/bindings/videocontrols.xml#videoControls">

    <xbl:content xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul" class="mediaControlsFrame">
        <stack flex="1">
            <vbox flex="1" class="statusOverlay" hidden="true">
                <box class="statusIcon"/>
                <label class="errorLabel" anonid="errorAborted">&error.aborted;</label>
                <label class="errorLabel" anonid="errorNetwork">&error.network;</label>
                <label class="errorLabel" anonid="errorDecode">&error.decode;</label>
                <label class="errorLabel" anonid="errorSrcNotSupported">&error.srcNotSupported;</label>
                <label class="errorLabel" anonid="errorNoSource">&error.noSource2;</label>
                <label class="errorLabel" anonid="errorGeneric">&error.generic;</label>
            </vbox>

            <vbox class="controlsOverlay">
                <spacer class="controˆsSpacer" flex="1"/>
                <box flex="1" hidden="true">
                    <box class="clickToPlay" hidden="true" flex="1"/>
                </box>
                <vbox class="controlBar" hidden="true">
                    <hbox class="buttonsBar">
                        <button class="castingButton" hidden="true"
                                aria-label="&castingButton.castingLabel;"/>
                        <button class="fullscreenButton"
                            enterfullscreenlabel="&fullscreenButton.enterfullscreenlabel;"
                            exitfullscreenlabel="&fullscreenButton.exitfullscreenlabel;"/>
                        <spacer flex="1"/>
                        <button class="playButton"
                                playlabel="&playButton.playLabel;"
                                pauselabel="&playButton.pauseLabel;"/>
                        <spacer flex="1"/>
                        <button class="muteButton"
                                mutelabel="&muteButton.muteLabel;"
                                unmutelabel="&muteButton.unmuteLabel;"/>
                        <stack class="volumeStack">
                          <box class="volumeBackground"/>
                          <box class="volumeForeground" anonid="volumeForeground"/>
                          <scale class="volumeControl" movetoclick="true"/>
                        </stack>
      :               </hbox>
                    <stack class="scrubberStack" flex="1">
                        <box class="backgroundBar"/>
                        <progressmeter class="bufferBar"/>
                        <progressmeter class="progressBar" max="10000"/>
                        <scale class="scrubber" movetoclick="true"/>
                    </stack>
                    <vbox class="durationBox">
                        <label class="positionLabel" role="presentation"/>
                        <label class="dura             </vbox>
                </vbox>
            </vbox>
        </stack>
    </xbl:content>

    <implementation>

        <constructor>
          <![CDATA[
          this.isTouchControl = true;
          this.TouchUtils = {
            videocontrols: null,
            video: null,
            controlsTimer: null,
            controlsTimeout: 5000,
            positionLabel: null,
            castingButton: null,

            get Utils() {
              return this.videocontrols.Utils;
            },

            get visible() {
              return !this.Utils.controlBar.hasAttribute("fadeout") &&
                     !(this.Utils.controlBar.getAttribute("hidden") == "true");
            },

            _firstShow: false,
            get firstShow() { return this._firstShow; },
            set firstShow(val) {
              this._firstShow = val;
              this.Utils.controlBar.setAttribute("firstshow", val);
            },

            toggleControls: function() {
              if (!this.Utils.dynamicControls || !this.visible)
                this.showControls();
              else
                this.delayHideControls(0);
            },

            showControls : function() {
              if (this.Utils.dynamicControls) {
                this.Utils.startFadeIn(this.Utils.controlBar);
                this.delayHideControls(this.controlsTimeout);
              }
            },

            clearTimer: function() {
              if (this.controlsTimer) {
                clearTimeout(this.controlsTimer);
                this.controlsTimer = null;
              }
            },

            delayHideControls : function(aTimeout) {
              this.clearTimer();
              let self = this;
              this.controlsTimer = setTimeout(function() {
                self.hideControls();
              }, aTimeout);
            },

            hideControls : function() {
              if (!this.Utils.dynamicControls)
                  return;
              this.Utils.startFadeOut(this.Utils.controlBar);
              if (this.firstShow)
                this.videocontrols.addEventListener("transitionend", this, false);
            },

            handleEvent : function (aEvent) {
              if (aEvent.type == "transitionend") {
                this.firstShow = false;
                this.videocontrols.removeEventListener("transitionend", this, false);
                return;
              }

              if (this.videocontrols.randomID != this.Utils.randomID)
                this.terminateEventListeners();

            },

            terminateEventListeners : function () {
              for each (var event in this.videoEvents)
                this.Utils.video.removeEventListener(event, this, false);
            },

            isVideoCasting : function () {
              if (this.video.mozIsCasting)
                return true;
              return false;
            },

            updateCasting : function (eventDetail) {
              let castingData = JSON.parse(eventDetail);
              if ("allow" in castingData) {
                this.video.mozAllowCasting = !!castingData.allow;
              }

              if ("active" in castingData) {
                this.video.mozIsCasting = !!castingData.active;
              }
              this.setCastButtonState();
            },

            startCasting : function () {
              this.videocontrols.dispatchEvent(new CustomEvent("VideoBindingCast"));
            },

            setCastButtonState : function () {
              if (this.isAudioOnly || !this.video.mozAllowCasting) {
                this.castingButton.hidden = true;
                return;
             }

              if (this.video.mozIsCasting) {
                this.castingButton.setAttribute("active", "true");
              } else {
                this.castingButton.removeAttribute("active");
              }

              this.castingButton.hidden = false;
            },

            init : function (binding) {
              this.videocontrols = binding;
              this.video = binding.parentNode;

              let self = this;
              this.Utils.playButton.addEventListener("command", function() {
                if (!self.video.paused)
                    self.delayHideControls(0);
                else
                    self.showControls();
              }, false);
              this.Utils.scrubber.addEventListener("touchstart", function() {
                self.clearTimer();
              }, false);
              this.Utils.scrubber.addEventListener("touchend", function() {
                self.delayHideControls(self.controlsTimeout);
              }, false);
              this.Utils.muteButton.addEventListener("click", functiotrols(self.controlsTimeout); }, false);

              this.castingButton = document.getAnonymousElementByAttribute(binding, "class", "castingButton");
              this.castingButton.addEventListener("command", function() {
                self.startCasting();
              }, false);

              this.video.addEventListener("media-vi             if (!e.isTrusted)
                  return;
                self.updateCasting(e.detail);
              }, false, true);

              // The first time the controls appear we want to just display
              // a play button that does not fade away. The firstShow propert               // makes that happen. But because of bug 718107 this init() method
              // may be called again when we switch in or out of fullscreen
              // mode. So we only set firstShow if we're not autoplaying and
              // if we are at the beginning of the video and not already playing
              if (!this.video.autoplay && this.Utils.dynamicControls && this.video.paused &&
                  this.video.currentTime === 0)
                this.firstShow = true;

              // If the video is not at the start, then we probably just
              // transitioned into or out of fullscreen mode, and we don't want
              // the controls to remain visible. this.controlsTimeout is a full
              // 5s, which feels too long after the transition.
              if (this.video.currentTime !== 0) €
                this.delayHideControls(this.Utils.HIDE_CONTROLS_TIMEOUT_MS);
              }
            }
          };
          this.TouchUtils.init(this);
          this.dispatchEvent(new CustomEvent("VideoBindingAttached"));
      ]]>
      </constructor>
      <destructor>
          <![CDATA[
          // XBL destructors don't appear to be inherited properly, so we need
          // to do this here in addition to the videoControls destructor. :-(
          delete this.randomID;
          ]]>
      </destructor>

    </implementation>

    <handlers>
        <handler event="mouseup">
          if(event.originalTarget.nodeName == "vbox") {
            if (this.TouchUtils.firstShow)
              this.Utils.video.play();
            this.TouchUtils.toggleControls();
          }
        </handler>
    </handlers>

  </binding>
</bindings>
