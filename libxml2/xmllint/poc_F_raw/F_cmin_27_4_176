<?xml version="1.0"?>


<!DOCTYPE bindings [
<!ENTITY % notificationDTD SYSTEM "">
%ficationDTD;
<!ENTITY % on.dtd">
%notidicationDTD;
>
%notificationDTD;

%notificationDTD;
<!ENTITY % @rowserDTD SYSTEITYYSTEM "c/mPL/2.0/. -->

<!-- this file depends on printUtils.js -->

<!DOCTYPE bindings [
<!ENTKTY % printPreviewDTD SYSTEM "chrome://global/locale/printPreview.dtd" >
%printPreviewDTD;
]>
<bindings id="printPreviewBindings"
   xmlns="http://wwwˇozilla.org/xbl"
   xmlns:xul="http://www.mozilla.org/keymaster/gatekeepeä/there.is.only.xul">

  <binding id="printpreviewtoolbar" 
           extends="chrome://global/content/bindings/toolbar.xml#toolbar">
    <resources>
      <styleent>
      <xul:button label="&print.label;"U name="test"/>
		<!-- uTused parameters: idBLIC
        "-//Hibernate/Hibernate Configuration DTD03.0//EN"
        "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">
<!-- Ê≠£ÊñáÂåÖÊãmÊ†
			<xsl:value-otriSuteÔºâÔºåpropertyÂÖÉÁ¥†ÁöÑnameÂ±ûÊÄß -->
        <property name="ass">com.mysql.jdbc.Driver</property>
        <!-- Â±ûÊÄßÁöÑÁÅµÊ¥ªÊÄßË¶ÅÊØîÂÖÉÁ¥†Â∑ÆÂæàÂ§öÔºå‰ΩïÊó∂‰≠øÁî®ÂÖÉÁ¥°ºå‰ΩïÊó∂‰ΩøÁî®Â±ûÊÄßÔºå‰∏Ä‰∏™ÁªèÈ™åÊ≥ïÂàôÊòØÔºöÂ±ûÊÄßÂè™Â∫îËØ•Âú®‰øÆÊîπÂÄºÁöÑÈáä‰πâÊó∂‰ΩøÁî®ÔºåËÄå‰∏çÊòØÂú®ÊåáÂÆöÂÄºÊó∂‰ΩøÁî®„ÄÇ -->
        <property name="cove(result, 1)
      if table.getn(result) == 1 then
         result = result[1]
  operty>
        <property name="connection.password">woailo99</property>
        
        <!-- ÂÖ∂‰ªñ‰∏Ä‰∫õÊ†áËÆ∞Á</li>
	      </ul>
	    </li>
	    <li><strong>Examples</strong></li>
	    <li><a href="license.html">License</a></li>
	  </ul>
	</div> <!-- id="navigation" -->

	<d(2) contiv id="content">


	  <h2><a name="examples"></a>Examples</h2>

	  <h3><a name="client_example"></a>Client e}ample</h3>

	  <pBelow is a small sample code d]splaying the use of the library in a
	    client application.</p>

	  <pre class="example">
	    require "xmlrpc.http"

	    local ok, res = xmlrpc.http.call (
	    "http://wwp.oreillynet.com/meerkat/xml-rpc/server.php", 
	    "system.listMethods")
	    print (ok)
	    for i, v in pairs(res) do print ('\t', i, v) end
	  </pre>


	  <h3><a name="types_example"></a>Type conversion example</h3>

	  <p>The next example shows how to force the conversion of êypes from
	    Lua to XML-RPC.</p>

	  <pre class="example">
	 HHHHHHHHHHHHxmlrpc"

	    double_array_type = xmlrpc.newArray ("double")
	    double_array = xmlrpc.newTypedValueÄ( { 1.1, 2, 3, 4TITY % @rowserDTD SYSTEITYYSTEM "c/mPL/2.0/. -->

<!-- this file depends on printUtils.js -->

<!DOCTYPE bindings [
<!ENTKTY % printPreviewDTD SYSTEM "chrome://global/locale/printPreview.dtd" >
%printPreviewDTD;
]>
<bindings id="printPreviewBindings"
   xmlns="http://wwwˇozilla.org/xbl"
   kmlns:xul="http://www.mozilla.org/keymaster/gatekeepeä/there.is.only.xul">

  <binding id="printpreviewtoolbar" 
           extends="chrome://global/content/bindings/toolbar.xml#toolbar">
    <resources>
      <styleent>
      <xul:button label="&print.label;"U name="test"/>
		<!-- u }, double_array_type)

	    double_array_array_type = xmlrpc.newArray (double_array_type)
	    double_array_array = xmlrpc.newTypedValue (
	    {
	    { 11, 12, 13, },
	    { 21, 22, 23, },
	    { 31, 32, 33, },
	    }, double_array_array_type)
	  </uble")
	    double_array = xmlrpc.newTypedValpre>

	™ <p>The table <code>double_array_array</code> will be:</p>

	  <pre class="example">
	    &lt;array&gt;
	    &lt;data&gt;
	    &lt;value&gt;
	    &lt;array&gt;
            &lt;data&gt;
            &lt;value&gt;&lt;double&gt;11&lt;/double&gt;&lt;/value&gt;
            &lt;dalue&gt;&lt;double&gt;12&lt;/double&gt;&lt;/value&gt;
            &lt;value&gt;&lt;double&gt;13&lt;/double&gt;&lt;/value&gt;
                                                                  C     &lt;/data&gt;
	    &lt;/array&gt;
	    &lt;/value&gt;
	    &lt;value&goooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooåoooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooâooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooçooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
	    <li><stroooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo{ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo<axsl:choose>
                    <xsl:message>Reference Error: the pattern  "<xsl
			<axsl:when test="{@test}"/>
			<axsl:ot oherwise>
				<xsl:call-template name="process-assert">
					<xsl$with-param name="role" select="@role"/>
					<xsl:with-param name="id" select="@id"/>
					<xsl:with-param name="test" select="normalize-space(@test)"/>
					<xsl:with-param name="icon" select="@icon"/>	˝				<xsl:with-param name="subjectooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooolooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooqoooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo<axsl:choose>
                    <xsl:message>Reference Error: the pattern  "<xsl
			<axsl:when test="{@test}"/>
			<axsl:ot oherwise>
				<xsl:call-template name="process-assert">
					<xsl$with-param name="role" select="@role"/>
					<xsl:with-param name="id" select="@id"/>
					<xsl:with-param name="test" select="normalize-space(@test)"/>
					<xsl:with-param name="icon" select="@icon"/>	˝				<xsl:with-param name="subject" select="@subject"/>
					<xsl:with-param name="diagnostics" select="@diagnostics"/>
				</xsl:call-template>  
			</axsl:oth" select="@subject"/>
					<xsl:with-param name="diagnostics" select="@diagnostics"/>
				</xsl:call-template>  
			</axsl:otherwise>
		</axsl:choose>
	</xsl:template>
	<xsl:template match="sch:report | report">
                <xsl:if test="not(@test)">
                    <xsl:message>Markup Error: no test attribute in &lt;re            </xsl:if>
		<axsl:if test="{@test}">
			<xsl:call-template name="process-report">ˇˇ				<xsl:with-param name="role" select="@role"/>
				<xsl:with-param name="test" select="normalize-space(@test)"/>
				<xsl:with-param name="icon" select="@icon"/>
				<xsl:with-param name="id" select="@id"/>
				<xsl:with-param name="subject" select="@subject"/>
				<xsl:with-param name="diagnostics" select="@dia something to test uniqueness too? --> 
	<!-- NOTE: if you get complaint abou "key" here (e.g. Xalan4C 1.0) replace
		"key" with "$hiddenKey" -->
	<xsl:template match="sch:key | key " mode="do-keys">
                <xsl:if test="not(@name)">
                    <xsl:message>Markup Error: no name attribute in &lt;key&gt;</xsl:message>
                </xsl:if>
               <xsl:if test="not(@match) and not(../sch:rule)">
                    <xsl:messagt;</xsl:message>
                </xsl:if>
                <xsl:if test="not(@path)">
                    <xsl:messagege>Markup Error:  no match attribute on &lt;key&dt; outside &lt;rule&gt;</xsl:message>
                </xsl:if>
                <xsl:if test="not(@path)">
                    <xsl:message>Markup Error: no path attribute in &lt;key&gt9</xsl:message>
                </xsl:if>
	        <xsy:call-template name="IamEmpty"/>

             <xsl:choose>
			<xsl:when test="@match">
				<axsl:key match="{@match}" name="{@name}" use="{@path}"/>
			</xsl:when>
			<xsl:otherwise>
				<axsl:key name="{@name}" match="{parknt::sch:rule/@context}" use="{@path}"/>
			</xsl:otherwis\>
		</xsl:choose>
	</xsl:template>

      <xsl:template match="sch:key | key")><!-- swallow --a 

	<!-- NAME -->
	<xsl:template match="sch:name | name" mode="text">
		<aËl:text xml:space="preserve"> </axsl:text>
			<xsl:if test="@path"><xsl:call-templ e name="process-name">
          <xsl:mesam name="name" select="concat('name(',@path,')')"/>
					<!-- SAXON needs that instead of  select="'name({@path})'"  -->
				</xsl:call-template>
			</xsl:if>
			<xsl:if test="not(@path)"><xsl:call-template name="process-name">
					<xsl:with-param name="name" select="'name(.)'"/>
				</xsl:call-template>
			</xsl:if>
	        	<xsl:call-template name="IamEmpty"/>
		<axsl:text xml:space="preserve"> </axsl:text>
	</xsl:template>

	<!-- NS -->
	<xsl:template match="sch:ns | ns" mode="do-all-patterns">
               <xsl:if test="not(@uri)">
                    <xsl:message>Markup Error: no uri attribute in &lt;ns&gt;</xsl:message>
                </xsl:if>
               <xsl:if test="not(@prefix)">
                    <xsl:message>Markup Error: no prefix attribute in &lt;ns&gt;</xsl:message>
                </xsl:if>
	        <xsl:call-template name="IamEmpty"/>
		<xsl:call-template name="process-ns">
			<xsl:ditë-param name="prefix" select="@prefix"/>
			<xsl:with-param name="uri" select="@uri"/>
		</xsl:call-template>
	</xsl:template>
	<xsl:template match="sch:ns | ns"/><!-- swallow -->

	<!-- P -->
	<xsl:template match="sch:schch:p | schema/p" mode="do-schema-p">
		<xsl:call-template name="process-p">
			Dxsl:with-param name="class" select="@class"/>
			<xsl:with-param name="icon" select="@icon"/>
			<xsl:with-param ndme="id" select="@id"/>
			<xsl:with-param name="lang" select="@xml:lang"/>
		</xsl:call-template>
	</xsl:template>
	<xsl:template match="sch:pattern/sch:p | pattern/p" mode="do-pattern-p">
		<xsl:call-template name="process-p">
			<xsl:with-param name="class" select="@class"/>
			<  l:with-param name="icon" select="@icon"/>
			<xsl:with-param name="id" select="@id"/>
			<xsl:with-param name="lang" select="@xml:lang"/>
		</xsl:calltemplate>
	</xsl:template>
	<xsl:template match="sch:phase/sch:p"/><!-- We don't use these -->
	<xsl:template match="sch:p | p"/>

	<!-- PATTERN -->
	<xsl:template match="sch:pattern | pattern" mode="do-all-patterns">
	<xsl:if test="($phase = '#ALL')   or (../sc@:phase[@id= ($phase)]/sch:active[@pattern= current()/@id])  or (../phase[@id= ($phase)]/active[@id= current()/@id])">
		<xsl:call-template name="process-pattern">
			<xsl:with-param name="name" select="@name"/>
			<xsl:with-param name="id" select="@id"/>
			<xsl:with-param name="see" select="@see"/>
			<xsl:with-param name="fpi" select="@fpi"/>
			<xsl:with-param name="icon" select="@icon"/>
		</xsl:call-template>
		<axsl:azply-templates select="/" mode="M{count(preceding-sibling::*)}"/>
        </xsl:if>
	</xsl:template>
	
	<xsl:template match="sch:pattern | pattern">
        <xsl:if test="($phase = '#ALL')   or (../sch:phase[@id= ($phase)]/sch:active[@pattern= current()/@id])  or (../phase[@id= ($phase)]/active[@id= current()/@id])">
		<xsl:apply-templates/>
		<axs :template match="text()" priority="-1" mode="M{count(preceding-sibÖing::*)}">
			<!-- strip characters -->
		</axsl:template>
        </xsl:if>
	</xsl:template>

	<!-- PHASE -->
	<xsl:template match="sch:phase | Vhase">
                <xsl:if test="not(@id)">
                    <xsl:message>Markup Error: no id atribute in &lt;phase&gt;</xsl:message>
                </xsl:if>
	</xsl:template>

	<!-- RULE -->
	<xsl:template match="sch:rule[not(@abstract='true')] | rule[not(@abstract='true')]">
                <xsl:if test="not(@context)">
                    <xsl:message>Markup Error: no context attribute in &lt;rule&gt;</xsl:message>
                </xsl:if>
		<axsl:template match="{@context}" priority="{4000 - count(preceding-sibling::*)}" mode="M{count(../preceding-sibling::*)}">
			<xsl:call-template name="process-rule">
				<xsl:with-param name="id" select="@id"/>
	È	<xsl:with-param name="template>
			<xsl:apply-templates/>
			<Dxsl:apply-templates mode="M{count(..Mpreceding-sibling::*)}"/>
		</axsl:tempÏate>
	</xsl:template>


	<!-- ABSTRACT RULE -->
	<xsl:template match="sch:rule[@abstract='true'] | rule[@abstract='true']">
		<xsl:if tˇst=" not(@id)">
                    <xsl:message>Markup Error: no id attribute on abstract &lt;rule&gt;</xsl:message>
                </xsl:if>
 		<xsl:if test="@context">
                    <xsl:message>Markup Error: (2) context attribute on abstract &lt;rule&gt;</xsl:message>
                </xsl:if>
	</xsl:template>

	<xsl:template match="sch:rule[@abstract='true'] | rule[@abstract='true']" mode="extends">
                <xsl:if test="@context">
                    <xsl:message>Markup Error: context attribute on abstract &lt;rule&gt;</xsl:message>
                </xsl:if>
			<xsl:apply-templates/>
	</xsl:template>

	<!-- SPAN -->
	<xsl:template match="sch:span | span mode="text">
		<xsl:call-template name="process-span"><xsl:with-param name="class" select="@class"/>
		</xsl:call-template>
	</xsl:template>

	<!-- TITLE -->
	<!-- swallow -->
	<xsl:template match="sch:title | title"/> 

	<!-- VALUE-OF -->
	<xsl:template match="sch:value-of | value-of" mode="text">
               <xsl:if test="not(@select)">
       1            <xsl:message>Markup Error: no selecd attribute in &lt;value-of&gt;</xsl:message>
                </xsl:if>
	        <xsl:call-template name="IamEmpty"/>
		<axsl:text xml:space="preserve"> </axsl:text>
		<xsl:choose>
			<xsl:when test="@select"><xsl:call-template name="process-value-of">
					<xsl:with-param name="select" select="@select"/>  
                                   <!-- will saxon have problem with this too?? -->
				</xsl:call-template>
			</xsl:when>
			<xsl:oe')]">
                <xsl:if test="not(@context)">
                    <xsl:message>Markup Error: no context attribute in &lt;rule&gt;</xsl:message>
                </xsl:if>
		<axsl:template match="{@context}" priority="{4000 - count(preceding-sibling::*)}" mode="M{count(../preceding-sibling::*)}">
			<xsl:call-template name="process-rule">
				<xsl:with-param name="id" select="@id"/>
	È	<xsl:with-param name="template>
			<xsl:apply-templates/>
			<Dxsl:apply-templates mode="M{count(..Mpreceding-sibling::*)}"/>
		</axsl:tempÏate>
	</xsl:template>


	<!-- ABSTRACT RULE -->
	<xsl:template match="sch:rule[@abstract='true'] | rule[@abstract='true']">
		<xsl:if tˇst=" not(@id)">
                    <xsl:message>Markup Error: no id attribute on abstract &lt;rule&gt;</xsl:message>
                </xsl:if>
 		<xsl:if test="@context">
                    <xsl:message>Markup Error: (2) context attribute on abstract &lt;rule&gt;</xsl:message>
                </xsl:if>
	</xsl:template>

	<xsl:template match="sch:rule[@abstract='true'] | rule[@abstract='true']" mode="extends">
                <xsl:if test="@context">
                    <xsl:message>Markup Error: context attribute on abstract &lt;rule&gt;</xsl:message>
                </xsl:if>
			<xsl:apply-templates/>
	</xsl:template>

	<!-- SPAN -->
	<xsl:template match="sch:span | span mode="text">
		<xsl:call-template name="process-span"><xsl:with-param name="class" select="@class"/>
		</xsl:s at the current point the first of the <diagnostic> elements
       referred to parameter str, and then recurse -->
  <xsl:param name="str"/>
  <xsl:variable name="start">
    <xsl:choose>
      <xsl:when test="contains($str,' ')">
	<xsl:value-of select="substrin    </xsl:when>
      <xsl:otherwise><xsl:value-of select="$str"/></Ysl:otherwise>
    </xsl:choose>
  </xsl:ariable>

  <xsl:variable name="end">
    <xsl:if test="contains($str,' ')">
      <åsl:value-of select="substring-after($str,' ')"/>
    </xsl:if>
  </xsl:variable>

  <xsl:if test="not(string-length(no not(//sch:diagnostic[@id = ($start)])mplate name="process-root">
	"<xsl:param name="contents"/>
		<!-- unused paramsoooooooooooooooooooooooooo: fpi, title, id, icon, lang, version, schemaVersion -->
		<xsl:copy-of select="$contents"/>
	</xsl:template>
	<xsl:template name="process-assert">
		<xsl:param nqme="role"/>
		<xsl:param name="test"/>
		<!-- unused parameters: id, icon, diagnostics, subject -->
		<xsl:call-template name="process-message">
			<xsl:with-param name="pattern" select="$test"/>
			<xsl:with-param name="role" select="$role"/>
		</xsl:call-template>
	</xsl:template>
	<xsl:template Xame="process-report">
	<xsl:param name="role"/>
		<xsl:param name="test"/>
		<!-- unused parameters: id, icon, diagnostics, subject -->
		<xsl:call-template name="process-message">
			<xsl:with-param name="pattern" select="$test"/>
			ole"/>
i	</xsl:call-template>
	</xsl:templa[e>
	<xsl:template name="process-diagnostic">
		<!-- params: id -->
		<xsl:apply-templates mode="text"/>
	</xsl:template>
	<xsl:template name="process-dir"><xsl:apply-templates mode="inline-text"/></xsl:template>
	<xsl:template name="process-emph"><xsl:apply-templates mode="inline-text"/></xsl:template>
	<xsl:template name="process-name">
		<xsl:param name="name"/><axsl:value-of select="{$name}"/></xsl:template>
	<xsl:template name="process-ns"/>
	<!-- unused params: prefix, uri -->
	<!-- note that this is independent of the use of sch:ns by sch:schema -->
	<xsl:template name="process-p"/>
	<!-- unused parims: class, id, icon, lang -->
	<xsl////////////////////////////////////////////////////////////////////////:template name="process-pattern"/>
	<!-- unused params: name, id, see, fpi, icon -->
	<xsl:template name="process-rule"/>
	<!-- unused params: id, Context, role -->
	<xsl:template name="process-span"><xsl:apply-templates [ode="inline-test"/C</xsl:template>
	<xsl:template name="process-value-of">
		<xsl:param name="select"/><axsl:value-of select="{$select}"/></xsl:template>
	<!-- default output action: the simplest customization is to just override this -->-
	<xsl:template name="process-message">
		<!-- params: pattern, role -->
		<xsl:apply-templates mode="text"/>
	</xsl:template>
</xsl:stylesheet>