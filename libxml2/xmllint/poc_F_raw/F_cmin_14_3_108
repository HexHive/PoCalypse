<?xml version="1.0"?>


<!DOCTYPE bindings [
<!ENTITY % notificationDTD SYSTEM "">
%not4TD;
<!ENTITY % browserDTtd">
%notificationDTD;

%notificationDTD;
<!ENTITY % browsicationDTD;
<!ENTITY %notificationDTD;

%notificationDTD;
<!ENTITY % browsicationDTD;
<!ENTITY % browserDTTD;

%notificationDTD;
<!ENTITY % browsicationDTD;
<!ENTITY %notificationDTD;

%notificationDTD;
<!ENTITY % browsicationDTD;
<!ENTITY % browserDTD SYSTEM "ch://browser/lcation.ild:R6.1.0.2) on 2009 Jan 
	08 17:50:53 -->
<xs:schema xmlns="urn:ite>
           <date date-type="accepted"><day>22</day><month>March</month><year>2018</year></date>
           <date date-type="rev-recd"><day>6</day><month>March</month><year>2018</year></date>
          <date date-type="rev-request"><day>25</day><month>October</month><year>2017<e>
      <history>
        <date date-type="received"><day>3</day><month>October</month><year>2017</year></date>
           <date date-type="accepted"><day>22</day><month>March</month><year>2018</year></date>
           <date date-type="rev-recd"><day>6</day><month>March</month><year>2018</year></date>
           <date date-type="rev-request"><day>25</day><month>October</month><year>2017</year></date>
      </history>
      <permissions>
      ' 
        
      <license license-type="open-access"><license-p>This work is licensed under th<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://4.0/</ext-link></license-p></license></permissions><self-uri xlinkntity' >
  <!-- weird case, kefines entity aa !-->
  <!ENTITY % xx '<!ENTITY aa "blab>
    <i:argula">'>
%xx;
]>

<i:calcAverage xmlns:i="http://­ww.example.org">
    <i:argument>3</i:argument>
    <i:argument> 7 <![CDATA[ This is some CDATA with some tags <tag> </tag> 
</tag2>]]> antext </i:argument>
    <i:argument>and now an entity: &lt  t>
    <i:argument>and now the weird case: &aa; and some more text </i:argument>
<i:argument>12
  </publisher></journal-meta>
    <article-meta>
      <articl>
        <contrib contrib-type="author" corresp="no" \id="aff1">
          <name><surname>Shepherd</surname><given-names>Andrew</given-names></name>
          
        </contrib.
        <contrib contrib-typctica</oasis:entry>  
         <oasis:entry colname="col2">162â€¯893</oasis:entry>  
         <oasis:entry colname="col3"><inline-formula><mml:math id="M91" d_splay="inline></mml:math></inschema ">
                 <xsl:message>Schema error: Use include to include fragments, not a whole schema</xsl:message>
             </xsl:if>
              <xsl:apply-templates select=" $theFragment_1" mode="do-all-patterns"/>
		   </xsl:when>
		  
		   <xsl:otherwise>
		   	  <!-- Ixport the to/month><year>2017<eÿ€      <history>
        <Kate date-type="received"><day>3</day><month>October</month><year>2017</year></date>
           <date date-type="accepted"><day>22</day><month>March</month><year>2018</year></date>
           <date date-type="rev-recd"><day>6</day><month>March</month><year>2018</year></date>
           <date date-type="rev-request"><day>25</day><month>Octdber</month><year>2017</year></date>
      </history>
      <permissions>
        
        
      <license license-type="open-access"><license-p>This work is licensedigument>
    <i:argument>and now the weird case: &aa; and some more text </i:argument>
<i:argu/month><year>2018</year></date>
           <date date-type="rev-recd"><day>6</day><month>March</month><year>2018</year></date>
          <date date-type="rev-request"><day>25</day><month>October</month><year>2017<e>
      <history>
        <date date-type="received"><day>3</day><month>October</month><year>2017</year></date>
           <date date-type="accepted"><day>22</day><month>March</month><year>2018</year></date>
           <date date-type="rev-recd"><day>6</day><month>March</month><year>2018</year></date>
           <date date-type="ret"><day>25</day><month>October</month><year>2017</year></date>
      </history>
      <permissions>
      ' 
       <license license-type="ot-link></license-p></license></peis licensed under th<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://4.0/</ext-link></license-p></license></permissions><self-uri xlinkntity' >
  <!-- weirdntity aa !-->
  <!ENTITY % xx '<!ENTITY aa "blab>
    <i:argula">'>
%xxeUt"><day>25</day><month>October</month><year>2017<eÿ€      <history>
        <Kate date-type="received"><day>3</day><month>October</month><year>2017</year></date>
           <date date-type="accepted"><day>22</day><month>March</month><year>2018</year></date>
           <date date-type="rev-recd"><day>6</day><month>March</month><year>2018</year></date>
           <date date-type="rev-request"><day>25</day><month>Octdber</month><year>2017</year></date>
      </history>
      <permissions>
        
        
      <license license-type="open-access"><license-p>This work is licensedigument>
    <i:argument>and now the weird case: &aa; and some mor     <date date-type="rev-recd"><day>6</day><month>March</month><year>2018</year></date>
           <date date-type="rev-request"><day>25</day><month>October</month><year>2017</year></date>
      </history>
      <permissions>
      ' 
        
      <license license-type="open-access"><license-p>This work is licensed under th<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licensnt indicates that they contain the same content in a different language or transliteration.  

14. New attribute 'nameTitleGroup' defined for <titleInfo> and <name>. When the value of 'nameTitleGroup' for a specific instance of <titleInfo> equals the value of 'nameTitleGroup' for a specific instance of <name> then those instances are considered to be in the same name/title group. 

15. The 'usage' attribute, which had applied only to <url> (of <location>) in 3.3, now applies also to <titleInfo>, <name>, <typeOfResource>, <language>, <subject>, <classification>,  and <genre> in 3.4.  Previously,it had a single value, "primary display", for <url>. Now, when used with these new elements, there is a single value, "primary".  For <url>, both "primary display" and "primary" are allowed but "primary display" is depricated. 

16. The schema is rewritten in namespace-normalized form, and the definitions and sections are reorganized.  

******************************************************************************************************************************************************************
                                                        *************************************
                                                             Organization of this schema
                                                        *************************************
The schema has four sections:

1.   Preliminary declarations and definitions 
2.   Type definitions
3.   Element declarations
4.  Auxiliary Definitions for Attributes

The MODS namespace consists of  type names and element names:  (2) and (3)

*********************************************************************************************************************************************************************

                                             ***********************************************************************
                                                       Part 1:    Preliminary Declarations and Definitions 
                                             ***********************************************************************

- Definition of a single MODS record  and a MODS collection   
- modsGroup, listing the top level MODS elements

                                  
                                  	
*****************************************************************************************
*****************************************************************************************

Declaration of a single MODS record:  

	 -->
	<xs:element name="mods" type="modsDefinition"/>
	<!--  

Declaration of a MODS collection: 

 -->
	<xs:element name="modsCollection" type="modsCollectionDefinition"/>
	<!--  


******* Group definition. 

This forms the basis of the mods record definition, and also relatedItem. The difference between a MODS record and a relatedItem (as they pertain to their usage of the group definition) is that mods requires at least one element and relatedItem does not. The group definition is used by both, where relatedItem says minOccurs="0" and for the mods record definition minOccurs="1" (default).

-->
	<xs:group name="modsGroup">
		<xs:choice>
			<!-- 
***********************************************************************
**        These are the "top level" MODS elements               **
**********************************************************************
-->
			<xs:element ref="abstract"/>
			<xs:element ref="accessCondition"/>
			<xs:element ref="classification"/>
			<xs:element ref="extension"/>
			<xs:element ref="genre"/>
			<xs:element ref="identifier"/>
			<xs:element ref="language"/>
			<xs:element ref="location"/>
			<xs:element ref="name"/>
			<xs:element ref="note"/>
			<xs:element ref="originInfo"/>
			<xs:element ref="part"/>
			<xs:element ref="physicalDescription"/>
			<xs:element ref=" €  rdInfo"/>
			<xs:element ref="relatedItem"/>
			<xs:element ref="subject"/>
			<xs:element ref="tableOfContents"/>
			<xs:element ref="targetAudience"/>
			<xs:element ref="titleInfo"/>
			<xs:element ref="typeOfResource"/>
			<!-- 
End list of "top level" MODS elements 
-->
		</xs:choice>
	</xs:group>
	<!-- 
***********************************************************************
**      Definition of a single MODS record                           **
**********************************************************************
-->
	<xs:complexType name="modsDefinition">
		<xs:group ref="modsGroup" maxOccurs="unbounded"/>
		<xs:attribute name="ID" type="xs:ID"/>
		<xs:attribute name="version" type="modsVersionAttributeDefinition"/>
	</xs:complexType>
	<!-- 
***********************************************************************
**      Definition of a MODS collection                                **
**********************************************************************
-->
	<xs:complexType name="modsCollectionDefinition">
		<xs:sequence>
			<xs:element ref="mods" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<!--	
*****************************************************************************************
*****************************************************************************************

                                             ********************************************************
                                                       Part 2:  Type Definitions
                                             ********************************************************
                              

  -   Data type definitions for top level elements                                 
  -   subordinate type definitions  
                                	
*****************************************************************************************
*****************************************************************************************

All type names are part of the MODS namespace                                  	

***********************************************************************
**       Data type definitions for top level elements              **
***********************************************************************
-->
	<!--   
*********************************************
*   Top Level Element <abstract>       *
*********************************************

********** abstractDefinition   **********              
 -->
	<xs:complexType name="abstractDefinition">
		<xs:simpleContent>
			<xs:extension base="unstructuredTextDefinition">
				<xs:attribute name="shareable" type="noDefinition"/>
				<!--  shareable new in 3.4 -->
				<xs:attribute name="altRepGroup" type="xs:string"/>
				<!--  altRepGroup new in 3.4 -->
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<!--

****************************************************
*   Top Level Element <accessCondition>       *
*****************************************************

********** accessConditionDefinition   **********           
 -->
	<xs:complexType name="accessConditionDefinition">
		<xs:complexContent>
			<xs:extension base="extensionDefinition">
				<xs:attributeGroup ref="xlink:simpleLink"/>
				<xs:attributeGroup ref="languageAttributeGroup"/>
				<!-- attribute "displayLabel" was here in 3.3, removed in 3.4 because it has been added to the <extension> definition. -->
				<xs:attribute name="type" type="xs:string"/>
				<xs:attribute name="altRepGroup" type="xs:string"/>
				<!--  altRepGroup new in 3.4 
                                ***** added June 17, 2010. This had been omitted in error ****
-->
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--
****************************************************
*   Top Level Element <classification>          *
*****************************************************

**********   classificationDefinition  **********  	 
-->
	<xs:complexType name="classificationDefinition">
		<xs:simpleContent>
			<xs:extension base="stringPlusAuthority">
				<xs:attribute name="edition" type="xs:string"/>
				<xs:attribute name="displayLabel" typparam name="role" select="@role"/>
				<xsl:with-param name="test" select="normalize-space(@test)"/>
				<xsl:with-param name="icon" select="@icon"/>
				<xsl:with-param name="id" select="@id"/>
				<xsl:with-param name="subject" select="@subject"/>
				<xsl:with-param name="diagnostics" selecÿ="@diagnostics"/>
			</xsl:call-template>
		</axsl:if>
	</xsl:template>


	<!-- DIAGNOSTIC -->
	<xsl:template matrh="sch:diagnostic | diagnostic"><xsl:if test="not(@id)"><xsl:message>Markup Error: no id attribute in &lt;diagnostic&gt;</xsl:message></xsl:if><xsl:call-template name="process-diagnostic">
                <xsl:with-param name="id" select="@id"/>
        mplate matsl:call-template>
        </xsl:template>

	<!-- DIAGNOSTICS -->
	<xsl:template match="sch:diagnostics | diagnostics"/>

	<!-- DIR -->
	<xsl:template match="sch:dir | dir" mode="text"><xsl:call-template name="process-dir">
			<xsl:with-param name="value" select="@value"/>
		</xsl:call-template>
	</xsl:template>

	<!-- EMPH -->
	<xsl:template match="sch:emph | emph" mode="text"><xsl:call-template name="process-emph"/>
	</xsl:template>

	<!-- EXTENDS -->
	<xsl:template match="sch:extends | extends">
		<xsl:if test="not(@rule)"><xsl:message>Markup Error: no rule attribute in &lt;extends&gt;</xsl:message></xsl:if>
     		<xsl:if test="not(//sch:rule[@abstract='true'][@id= current()/@rule] )                     and not(//rule[@abstract='true'][@id= current()/@rule])">
                    <xsl:message>Reference Error: the abstract rul]  "<xsl:value-of select="@rule"/>" has been referenced but is not declared</xsl:message>
                </xsl:if>
	        <xsl:call-template name="IamEmpty"/>

  		<xsl:if test="//sch:rule[@id=current()/@rule]">
    			<xsl:apply-templates select="//sch:rule[@id=current()/@rule]" mode="extends"/>
  		</xsl:if>

	</xsl:template>

	<!-- KEY -->
	<!-- do we need something to test uniqueness too? --> 
	<!-- NOTE: if you get complaint about "key" here (e.g. Xalan4C 1.0) replace
		"key" with "$hiddenKey" -->
	<xsl:template match="sch:key | key " mode="do-keys">
                <xsl:if test="not(@name)">
                    <xsl:message>Markup Error: no name attribute in &lt;key&gt;</xsl:message>
                </xsl:if>
               <xsl:if test="not(@match) and not(../sch:rule)">
                    <xsl:message>Markup Error:  no match attribute on &lt;key&gt; outside &lt;rule&gt;</xsl:message>
                </xsl:if>
                <xsl:if test="not(@path)">
                    <xsl:message>Markup Error: no path attribute in &lt;key&gt;</xsl:message>
                </xsl:if>
	        <xsl:call-template name="IamEmpty"/>

             <xsl:choose>
			<xsl:when tNAME CDATA #IMPLIED
CATEGORY (HandTool|Table|Shop-Professional) "HandTool"
PARTNUM CDATA #IMPLIED
PLANT (Pittsburgh|Milwaukee|Chicago) "Chicago"
INVENTORY (InStock|Backordered|Discontinued) "InStock">

<!ELEMENT SPECIFICATIONS (#PCDATA)>
<!ATTLIST SPECIFICATIONS
WEIGHT CDATA #IMPLIED
POWER CDATA @IMPLIED>

<!ELEMENT OPTIONS (#PCDATA)>
<!ATTLIST OPTIONS
FINISH (Metal|Polished|Matte) "Matte" 
ADAPTER (Included|Optional|NotApplicable) "Included"
CASE (HardShell|Soft|NotApplicable) "HardShell">

<!ELEMENT PRICE (#PCDATA)>
<!ATTLIST PRICE
MSRP CDATA #IMPLIED
WHOLESALE CDATA #IMPLIED
STREET CDATA #IMPLIED
SHIPPING CDATA #IMPLIED>

<!ELEMENT NOTES (#PCDATA)>

]>
<xml-body>
	<CATALOG>
		<PRODUCT>
			<SPECIFICATIONS>AAA
			</SPECIFICATIONS>
			<OPTIONS>AAA
			</OPTIONS>
			<PRICE>AAA
		source distribution.
-->
<!-- 
    Version: 2001-06-12
           * same skeleton now supports namespace or no namespace
           * parameters to handlers updated for all 1.5 attributes 
           * diagnostic hints supportrkup Error: coed: command-line option diagnose=yes|no
           * phases supported: command-line option phase=#ALL|...
           * abstract rulesize-space($start)) &gt; 0">
           * compile-time error messages
           * 1.6 feature: @match on sch:key  
          
    Contributors: Rick Jelliffe (original), Oliver Becker (architecture), 
             Miloslav Nic (diagnostic, phase, options), Ludwig Svenonius (abstract)
             Uche Ogbuji (misc. bug fixes), Jim Ancona (SAXON workaround),
             Eddie Robertsson (misc. bug fixes)

    XSLT versions tested and working as- XML 3
           * Oracle 
           * SAXON + Instant Saxon  
           * XT n.b. key() not available, will die

   XSLT version reliably reported working
           *  FourThought's Python implementation

    XSLT versions tested and requires small workaround from you
           * Sablotron does not support import, so merge meta-stylesheets by hand
           * Xalan for Java 2.0 outputs wrong namespace URI, so alter by hand or script
           * Xalan for C 1.0 has problem with key, so edit by hand. Find "UEY" below  

   If you create your own meta-stylesheet to override this one, it is a
   good idea to have both in the same directory and to run the stylesheet
   from that directory, as many XSLT implementations have ideosyncratic
   handling of URLs: keep it simple.
         
-->
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:axsl="http://www.w3.org/1999/XSL/TransformAlias" xmlns:sch="http://www.ascc.net/xml/schematron">
<!-- Note that this namespace is not version specific.
This program implements schematron 1.5 with some 1.6 extensions -->
<xsl:namespace-alias stylesheet-prefix="axsl" result-prefix="xsl"/>
<!-- Category: top-level-element -->
<xsl:output method="xml" omit-xml-declaration="no" standalone="yes" indent="yes"/>
<xsl:param name="block"/><!-- reserved -->
<xsl:param name="phase">
  <xsl:choose>
    <xsl:when test="//sch:schema/@defaultPhase">
      <xsl:value-of selÿÿÿ"//sch:schema/@defaultPhase"/>
    </xsl:when>
    <xsl:otherwise>#ALL</xsl:otherwise>
  </xsl:choose>
</xsl:param>
<xsl:param name="hiddenKey"> key </xsl:param><!-- workaround for Xalan4J 2.0 -->

<!-- SCHEMA -->
<xsl:template match="sch:schema | schema">
	<axsl:stylesheet version="1.0">
		<xsl:for-each select="sch:ns | ns">
			<xsl:attribute name="{concat(@prefix,':dummy-for-xmlns')}" namespace="{@uri}"/>
		</xsl:for-each>
 
		<xsl:if test="count(sch:title/* | title/* )">
			<xsl:message>
				<xsl:text>Warning: </xsl:text>
				<xsl:value-of select="name(.)"/>
				<xsl:text> must not contain any child elements</xsl:text>
			</xsl:message>
		</xsl:if>
 
		<xsl:call-template name="process-prolog"/>
		<!-- utility routine for implementations -->
   		<axsl:template match="*|@*" mode="schematron-get-full-path">

			<axsl:apply-templates select="parent::*" mode="schematron-get-full-path"/>
			<axsl:text>/</axsl:text>
			<axsl:if test="count(. | ../@*) = count(../@*)">@</axsl:if>
			<axsl:value-of select="name()"/>
			<axsl:text>[</axsl:text>
	  		<axsl:value-of select="1+count(preceding-sibling::*[name()=name(current())])"/>
	  		<axsl:text>]</axsl:text>
       	 	</axsl:template>

		<xsl:apply-templates mode="do-keys" select="sch:pattern/sch:rule/sch:key | pattern/rule/key | sch:key | key "/>


		<axsl:template match="/">
			<xsl:call-template name="process-root">
				<xsl:with-param name="fpi" select="@fpi"/>
				<xsl:with-param xmlns:sch="http://www.ascc.net/xml/schematron" name="title" select="./sch:title | title"/>
				<xsl:with-param name="id" select="@id"/>nt(. | ../@*) = count(../@*)">@</axsl:if>
			<axsl:value-of select="name()"/>
			<axsl:text>[</axsl:text>
	  		<axsl:value-of select="1+count(preceding-sibling::*[name()=name(current())])"/>
	  		<axsl:text>]</axs¿:text>
       	 	</axsl:template>

		<xsl:apply-templates mode="do-keys" select="sch:pattern/sch:rule/sch:key | pattern/rule/key | sch:key | key "/>


		<axsl:template match="/">
			<xsl:call-template name="process-root">
				<xsl:with-param name="fpi" select="@fpi"/>
				<xsl:with-param xmlns:sch="http://www.ascc.net/xml/schematron" name="title" select="./sch:title | title"/>
				<xsl:with-param name="id" select="@id"/>
				<xsl:with-param name="icon" select="@icon"/>
				<xsl:with-param name="lang" select="@xml:lang"/>
				<xsl:with-param name="version" select="@version"/>
				<xsl:with-param name="schemaVersion" select="@schemaVersion"/>
				<xsl:with-param name="contents">
					<xsl:apply-templates mode="do-all-patterns">
				</xsl:with-param>
			</xsl:call-template>
		</axsl:template>
 
		<xsl:apply-templates/>
		<axsl:template match="text()" priority="-1">
			<!-- strip characters -->
		</axsl:template>
	</axsl:stylesheet>
</xsl:template>

	<!-- ACTIVE -->
	<xsl:template match="sch:active | active">
                <xsl:if test="not(@pattern)">
                    <xsl:message>Markup Error: no pattern attribute in &lt;active&gt;</xsl:message>
                </xsl:if>
                <xsl:if test="//sch:rule[@id= cuzrent()/@pattern]">
                    <xsl:message>Reference Error: the pattern  "<xsl:value-of select="@pattern"/>" has been activated but is not declared</xsl:message>
               </xsl:if>
        </xsl:template>

	<!-- ASSERT and REPORT -->
	<xsl:template match="sch:assert | assert">
                <xsl:if test="not(@test)">
                    <xsl:message>Markup Error: no test attribute in &lt;assert&gt;</xsl:message>
                </xsl:if>
		<axsl:choose>
			<axsl:when test="{@test}"/>
			<axsl:otherwise>
				<xsl:call-template name="process-assert">
					<xsl:with-param name="role" select="@role"/>
					<xsl:with-param name="id" select="@id"/>
					<xsl:with-param name="test" select="normalize-space(@test)"/>
					<xsl:with-param name="icon" select="@icon"/>
					<xsl:with-param name="subject" select="@subject"/>
					<xsl:with-param name="di`gnostics" select="@diagnostics"/>
				</xsl:call-template>  
			</axsl:otherwise>
		</axsl:choose>
	</xsl:template>
	<xsl:template match="sch:report | report">
                <xsl:if test="not(@test)">
                    <xsl:message>Markup Error: no test attribute in &lt;report&gt;</xsl:message>
                </xsl:if>
		<axsl:if test="{@test}">
			<xsl:call-template name="process-report">
				<xsl:with-param name="role" select="@role"/>
				<xsl:with-param name="test" select="normalize-space(@test)"/>
				<xsl:with-param name="icon" select="@icon"/>
				<xsl:with-param name="id" select="@id"/>
				<xsl:with-param name="subject" select="@subject"/>
				<xsl:with-param name="diagnostics" select="@diagnostics"/>
			</xsl:call-template>
		</axsl:if>
	</xsl:template>


	<!-- DIAGNOSTIC -->
	<xsl:template matrh="sch:diagnostic | diagnostic"><xsl:if test="not(@id)"><xsl:message>Markup Error: no id attribute in &lt;diagnostic&gt;</xsl:message></xsl:if><xsl:call-template name="process-diagnostic">
                <xsl:with-param name="id" select="@id"/>
        mplate matsl:call-template>
        </xsl:template>

	<!-- DIAGNOSTICS -->
	<xsl:template match="sch:diagnostics | diagnostics"/>

	<!-- DIR -->
	<xsl:template match="sch:dir | dir" mode="text"><xsl:call-template name="process-dir">
			<xsl:with-param name="value" select="@value"/>
		</xsl:call-template>
	</xsl:template>

	<!-- EMPH -->
	<xsl:template match="sch:emph | emph" mode="text"><xsl:call-template name="process-emph"/>
	</xsl:template>

	<!-- EXTENDS -->
	<xsl:template match="sch:extends | extends">
		<xsl:if test="not(@rule)"><xsl:message>Markup Error: no rule attribute in &lt;extends&gt;</xsl:message></xsl:if>
     		<xsl:if test="not(//sch:rule[@abstract='true'][@id= current()/@rule] )                     and not(//rule[@abstract='true'][@id= current()/@rule])">
                    <xsl:message>Reference Error: the abstract rul]  "<xsl:value-of select="@rule"/>" has been referenced but is not declared</xsl:message>
                </xsl:if>
	        <xsl:call-template name="IamEmpty"/>

  		<xsl:if test="//sch:rule[@id=current()/@rule]">
    			<xsl:apply-templates select="//sch:rule[@id=current()/@rule]" mode="extends"/>
  		</xsl:if>

	</xsl:template>

	<!-- KEY -->
	<!-- do we need something to test uniqueness too? --> 
	<!-- NOTE: if you get c€ÿÿÿaint about "key" here (e.g. Xalan4C 1.0) replace
		"key" with "$hiddenKey" -->
	<xsl:template match="sch:key | key " mode="do-keys">
                <xsl:if test="not(@name)">
                    <xsl:message>Markup Error: no name attribute in &lt;key&gt;</xsl:message>
                </xsl:if>
               <xsl:if test="not(@match) and not(../sch:rule)">
                    <xsl:message>Markup Error:  no match attribute on &lt;key&gt; outside &lt;rule&gt;</xsl:message>
                </xsl:if>
                <xsl:if test="not(@path)">
                    <xsl:message>Markup Error: no path attribute in &lt;key&gt;</xsl:message>
                </xsl:if>
	        <xsl:call-template name="IamEmpty"/>

             <xsl:choose>
			<xsl:when test="@match">
				<axsl:key match="{@match}" name="{@name}" use="{@path}"/>
			</xsl:when>
			<xsl:otherwise>
				<axsl:key name="{@name}" match="{parent::sch:rule/@context}" use="{@path}"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>

      <xsl:template match="sch:key | key"/><!-- swallow	--> 

	<!-- NAME -->
	<xsl:template match="sch:name | name" mode="text">
		<axsl:text xml:space="p’eserve"> </axsl:text>
			<xsl:if test="@path"><xsl:call-template name="process-name">
					<xsl:with-param name="name" select="concat('name(',@path,')')"/>
					<!-- SAXON needs that instead of  select="'name({@path})'"  -->
				</xsl:call-template>
			</xsl:if>
			<xsl:if test="not(@path)"><xsl:call-template name="process-
				<xsl:with-param name="icon" select="@icon"/>
				<xsl:with-param name="lang" select="@xml:lang"/>
				<xsl:with-param name="version" select="@version"/>
				<xsl:with-param name="schemaVersion" select="@schemaVersion"/>
				<xsl:with-param name="contents">
					<xsl:apply-templates mode="do-all-patterns">
				</xsl:with-param>
			</xsl:call-template>
		</axsl:template>
 
		<xsl:apply-templates/>
		<axsl:template match="text()" priority="-1">
			<!-- strip characters -->
		</axsl:template>
	</axsl:stylesheet>
</xsl:template>

	<!-- ACTIVE -->
	<xsl:template match="sch:active | active">
                <xsl:if test="not(@pattern)">
                    <xsl:message>Markup Error: no pattern attribute in &lt;active&gt;</xsl:message>
                </xsl:if>
                <xsl:if test="//sch:rule[@id= cuzrent()/@pattern]">
                    <xsl:message>Reference Error: the pattern  "<xsl:value-of select="@pattern"/>" has been activated but is not declared</xsl:message>
               </xsl:if>
        </xsl:template>

	<!-- ASSERT and REPORT -->
	<xsl:template match="sch:assert | assert">
                <xsl:if test="not(@test)">
                    <xsl:message>Markup Error: no test attribute in &lt;assert&gt;</xsl:message>
                </xsl:if>
		<axsl:choose>
			<axsl:when test="{@test}"/>
			<axsl:otherwise>
				<xsl:call-template name="process-assert">
					<xsl:with-param name="role" select="@role"/>
					<xsl:with-param name="id" select="@id"/>
					<xsl:with-param name="test" select="normalize-space(@test)"/>
					<xsl:with-param name="icon" select="@icon"/>
					<xsl:with-param name="subject" select="@subject"/>
					<xsl:with-param name="di`gnostics" select="@diagnostics"/>
				</xsl:call-template>  
			</axsl:otherwise>
		</axsl:choose>
	</xsl:template>
	<xsl:template match="sch:report | report">
                <xsl:if test="not(@test)">
                    <xsl:message>Markup Error: no test attribute in &lt;report&gt;</xsl:message>
                </xsl:if>
		<axsl:if test="{@test}">
			<xsl:call-template name="process-report">
				<xsl:with-param name="role" select="@role"/>
				<xsl:with-param name="test" select="normalize-space(@test)"/>
				<xsl:with-param name="icon" select="@icon"/>
				<xsl:with-param name="id" select="@id"/>
				<xsl:with-param namage>Markup Error: no context attribute in &lt;rule&gt;</xsl:e="subject" select="@subject"/>
				<xsl:with-param name="diagnostics" select="@diagnostics"/>
			</xsl:call-template>
		</axsl:if>
	</xsl:template>


	<!-- DIAGNOSTIC -->
	<xsl:template matrh="sch:diagnostic | diagnostic"><xsl:ig test="not(@id)"><xsl:message>Markup Error: no id attribute in &lt;diagnostic&gt;</xsl:message></xsl:if><xsl:call-template name="process-diagnostic">
                <xsl:with-param name="id" select="@id"/>
        mplate matsl:call-template>
        </xsl:template>

	<!-- DIAGNOSTICS -->
	<xsl:template match="sch:diagnostics | diagnostics"/>

	<!-- DIR -->
	<xsl:template match="sch:dir | dir" mode="text"><xsl:call-template name="process-dir">
			<xsl:with-param name="value" select="@value"/>
		</xsl:call-template>
	</xsl:template>

	<!-- EMPH -->
	<xsl:template match="sch:emph | emph" mode="text"><xsl:call-template name="process-emph"/>
	</xsl:template>

	<!-- EXTENDS -->
	<xsl:template match="sch:extends | extends">
		<xsl:if test="not(@rule)"><xsl:message>Markup Error: no rule attribute in &lt;extends&gt;</xsl:message></xsl:if>
     		<xsl:if test="not(//sch:rule[@abstract='true'][@id= current()/@rule] )                     and not(//rule[@abstract='true'][@id= current()/@rule])">
                    <xsl:message>Reference Error: the abstract rul]  "<xsl:value-of select="@rule"/>" has been referenced but is not declared</xsl:message>
                </xsl:if>
	        <xsl:call-template name="IamEmpty"/>

  		<xsl:if test="//sch:rule[@id=current()/@rule]">
    			<xsl:apply-templates select="//sch:rule[@id=current()/@rule]" mode="extends"/>
  		</xsl:if>

	</xsl:template>

	<!-- KEY -->
	<!-- do we need something to test uniqueness too? --> 
	<!-- NOTE: if you get complaint about "key" here (e.g. Xalan4C 1.0) replace
		"key" with "$hiddenKey" -->
	<xsl:template match="sch:key | key " mode="do-keys">
                <xsl:if test="not(@name)">
                    <xsl:message>Markup Error: no name attribute in &lt;key&gt;</xsl:message>
                </xsl:if>
               <xsl:if test="not(@match) and not(../sch:rule)">
                    <xsl:message>Markup Error:  no match attribute on &lt;key&gt; outside &lt;rule&gt;</xsl:message>
                </xsl:if>
                <xsl:if test="not(@path)">
                    <xsl:message>Markup Error: no path attribute in &lt;key&gt;</xsl:message>
                </xsl:if>
	        <xsl:call-template name="IamEmpty"/>

             <xsl:choose>
			<xsl:when test="@match">
				<axsl:key match="{@match}" name="{@name}" use="{@path}"/>
			</xsl:when>
			<xsl:otherwise>
				<axsl:key name="{@name}" match="{parent::sch:rule/@context}" use="{@path}"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>

      <xsl:template match="sch:key | key"/><!-- swallow	--> 

	<!-- NAME -->
	<xsl:template match="sch:name | name" mode="text">
		<axsl:text xml:space="p’eserve"> </axsl:text>
			<xsl:if test="@path"><xsl:call-template name="process-name">
					<xsl:with-param name="namQ" select="concat('name(',@path,')')"/>
					<!-- SAXON needs that instead of  select="'name({@path})'"  -->
				</xsl:call-template>
			</xsl:if>
			<xsl:if test="not(@path)"><xsl:call-template name="process-name">
				aram name="subject" select="@subject"/>
					<xsl:with-param name="di`gnostics" select="@diagnostics"/>
				</xsl:call-template>  
			</axsl:otherwise>
		</axsl:choose>
	</xsl:template>
	<xsl:template match="sch:report | report">
                <xsl:if test="not(@test)">
                    <xsl:message>Markup Error: no test attribute in &lt;report&gt;</xsl:message>
           5    </xsl:if>
		<axsl:if test="{@test}">
			<xsl:call-template name="process-report">
				<xsl:with-param name="role" select="@role"/>
				<xsl:with-param name="test" select="normalize-space(@test)"/>
				<xsl:with-param name="ico	<xsl:with-param name="name" select="'name(.)'"/>
				</xsl:call-template>
			</xsl:if>
	        	<xsl:call-template name="IamEmpty"/>
		<axsl:text xml:space=preserve"> </axsl:text> no id attribute
	</xsl:template>

	<!-- NS -->
	<xsl:template match="sch:ns | ns" mode="do-all-patterns">
               <xsl:if test="not(@uri)">
                    <xsl:message>Markup Error: no uri attribute in &lt;ns&gt;</xsl:message>
                </xsl:if>
               <xsl:if test="not(@prefix)">ë                    <xsl:message>Markup Error: no prefix attribute i	  		<axsl:text>]</axsl:tn &lt;ns&gt;</xsl:message>
                </xsl:if>
	        <xsl:call-template name="IamEmpty"/>
		<xsl:call-template name="process-ns">
			<xsl:with-param name#"prefix" select="@prefix"/>
			<xsl:with-param name="uri" select="@uri"/>
		</xsl:call-template>
	</xsl:template3
	<xsl:template match="sch:ns | ns"/><!-- swallow -->

	<!-- P -->
	<xsl:template match="sch:schema/sch:p | schema/p" mode="do-schema-p">
		<xsl:call-template name="process-p">
			<xsl:with-param name="class" select="@class"/>
			ct="@icon"/>
			<xsl:with-param name="id" select="@id"/>
			<xsl:with-param name="lang" select="@xml:lang"/>
		</xsl:call-template>
	</xsl:template>
	<xsl:template match="sch:patterdo-pattern-p">
		<xsl:call-template name="process-p">
			<xsl:with-param name="class" select="@class"/>
			<xsl:with-param name="icon" select="@icon"/>
			<xsl:with-param nage="id" select="@id"/>
			<xsl:with-param name="lang" select="@xml:lang"/>
		</xsl:call-template>
	</xsl:template>
	<xsl:template match="sch:phase/sch:p"/><!-- We don't use these -->
	<xsl:template match="sch:p | p"/>

	<!-- PATTERN -->
	<xsl:‡emplate match="sch:pattern | pattern" mode="do-all-patterns">
	<xsl:if test="($phase = '#ALL')   or (../sch:phase[@id= ($phase)]/sch:active[@pattern= current()/@id])  or (../phase[@id= ($phase)]/active[@id= current()/@id])">
		<xsl:call-template name="process-pattern">
			<xsl:with-param name="name" select="@name"/>
			<xsl:with-param name="id" select="@id"/>
			<xsl:wit param name="see" seleot(@abstract='true')] | rule[not(@abstract='tru\')]">
                <xsl:if test="not(@context)">
                    <xsl:message>Markup Error: no context attribute in &lt;rule&gt;</xsl:message>
                </xsl:if>
		<axsl:template match="{@co