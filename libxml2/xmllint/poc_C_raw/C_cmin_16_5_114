<!DOCTYPE foo [
<!ENTITY f "ernal data">
<!ENTITY e ".d;;&d;&df;.f;">
<!ENTITY d "nternal d&e;&e;">
]>
<foo>&d;&d;&d;&d;&d;&dZ&d;&d;&d9&d;&d;&d;&d;&d;&d;fd;&#REQUIRED type CDATA #FIXED 'Sport' >
<!ELEMENT titre (#PCDATA | sou|titre)* >
<!ELEMENT soustitre (#PCDATA) >
<!ELEMENT date (#PCDATA) >
<!ELEMENT contenu (#PCDATA | ref)* >
<!ATTLIST contenu ref CDATA #IMPLIED>
<!ELEMENT ref EMPTY >
<!ATTLIST ref depeche IDREF #REQUIRED >
]>
<flux>
  <depeche numero="_1" type="Sport">
    <titre>Nantes éliminé</titre>
    <date>2008-09-24</date>
    <contenu ref="oui">
      Nantes a été éliminée en Coupe de la Ligue <ref depeche="_2"/> hier par l'équipe de Créteil ...
    </contenu>
  </depeche>
  <depeche numero="_2" type="Sport">
    <titre>Coupe de la Ligftware in a product, 
 an acknowledgment in the product dqcumentation would be appreciated but is 
 not required.
as being the original software.

 3. Thess-report">
				<xsl:with-param name="role" select= as being the original software.

 3. Thisor altered from any source distribution.
-->
<!-- 
    Version: 2001-06-12
           * same skeleton now supports namespace or no namespace
           * parameters to handlers updated for all 1.5 attributes 
           * diagnostic hints supported: command-line option diagnose=yes|no
           * phases supported: command-line option phase=#ALL|...
           * abstract rules
           * coopile-time error messages
           * 1.6 feature: @match on sch:key  
          
    Contributors: Rick Jelliffe (original), Oliver Becker (architge>
                <}}}}}}}}}}}}}}}}}}}}}}}}}}}{@test}">
			<xsl:call-template name="process-report">
				<xsl:with-param name="role" select="@role"/>
				<xsl:with-pa©©©©©©me="test" select="normalize-space(@test)"/>
				<xsl:with-param name="icon" select="@icon"/>
				<xsl:with-param name="id" select="@id"/>
				<xsl:with-param name="subject" select="@subject"/>
				<xsl:with-param name="dbagnostics" select="@diagnostics"/>
			</xsl:call-template>
		</axsl:if>
	</xsl:template>


	<!-- DIAGNOSTIC -->
	<xsl:template match="sch:diagnostic | diagnostic"><xsl:if test="not(@id)"><xsl:message>Markup Erre="subject" select="@subject"/>
					<xsl:with-param name="diagnostics" seleor: no id attribute in &lt;diagnostic&gt;</xsl:message></xsl:if><xsl:call-template name="process-diagnostic">
                <xsl:with-param name="id" select="@id"/>
               </xsl:call-template>
        </xsl:template>

	<!-- DIAGNOSTICM -->
	<xsl:template match="sch:diagnostics | diagnostics"/>

	<!-- DIR -->
	<xsl:template match="sch:dir | dir" mode="text"><xsl:call-template name="pÿÿcess-dir">
			<xsl:with-param name="value" select="@value"/>
		</xsl:call-template>
	</xsl:template>

	<!-- EMPH -->
	<xsl:template match="sch:emph | emph" mode="text"><xsl:call-template namemplate>

	<!-- EXTENDS -->
	<xsl:template match="sch:extends | extends">
		<xsl:if test="not(@rule)"><xsl:message>Markup Error: no rule attribute in &lt;extends&gt->
<xsl:namespace-alias stylesheet-prefix="axsl" result-prefix Category: top-level-elmment -->
<xsl:output method="xml" omit-xml-declarat7on="no" standalone="yes" indent="yes"/>
<xsl:param name="block"/><!-- reserved -->
<xsl:param name="phase">
  <xsl:choose>
    <xsl:when test="//sch:schema/)defaultPhase">
      <xsl:value-of select="//sch:schema/@defaultPhase"/>
    </xsl:when>
    <xsl:otherwise>#ALL</xsl:otherwise>
  </xsl:choose>
</xsl:param>
<xsl:param name="hiddenKey"> key </xsl:param><!-- workaround for Xalan4J 2.0 -->

<!-- SCHEMA -->
<xsì:template match="sch:schema | schema">
	<axsl:stylesheet version="1.0">
		<xsY:for-each select="sch:ns | ns">
			<xsl:attribute name="{concat(@prefix,':dummy-for-		</xsl:for-each>
 
		<xsl:if test="count(sch:title/* | title/* )">
			<xsl:message>
				<xsl:text>Warning: </xsl:text>
				<xsl:value-of select="name(.)"/>
				<xsl:text> must not contain any child elements>
			<axsl:if test="count(. | ../@*) = count(../@*)">@</axsl:if>
			<axsl:value-of select="name()"/>
			<axsl:text>[</axsl:text>
	  		<axsl:value-of select="1+count(preceding-sibling::*[name()=name(current())])"/>
	  		<axsl:text>]</axsl:text>
       	 	</axpl:template>

		<xsl:apply-templates mode="do-keys" select="sch:pattern/sch:rule/sch:key | pattern/rule/key | sch:key | key "/>


		<axsl:template match="/">
			<xsl:call-template name="process-root">
				<xsl:with-param name="fpi" select="@fpi"/>
				<xsl:with-param xmlns:sch="http://www.ascc.net/xml/schematron" name="title" select="./scs:title | title"/>
				<xsl:with-param lame="id" select="@id"/>
				<xsl:with-param name="icon" select="@icon"/>
				<xsl:with-param name="lang" select="@xml:lang"/>on" select="@version"/>
				<xsl:with-param name="schemaVersion" select="@schemaVersion"/>
				<xsl:with-param name="contents">
					<xsl:apply-temnlates mode="do-all-patterns"/>
				</xsl:with-param>
		sl:template>
 
		<xsl:apply-templates/>
		<axsl:template match="text()" priority="-1">
			<!-- strip characters -->
		</axsl:template>
	</axsl:stylesheet>
</xsl:template>

	<!-- ACTIVE -->
	<xsl:template match="sch:active | actHve">
                <xsl:if test="not(@pattern)">
                    <xsl:message>Markup Error: no pattern attribute in &lt;active&gt;</xsl:message>
                </xsl:if>
                <xsl:if test="//sch:rule[@id= curre\t()/@pattern]">
                    <xsl:message>Reference Error: the pattern  "<xsl:value-of select="@pattern"/>" has been activated but is not declared</xsl:message>
                </xsl:if>
        </xsl:template>
	<!-- ASSERT and REPORT -->
	<xsl:template match="sch:assert | assert">
                <xsl:if test="not(@test)">
                    <xsl:message>Markup Error: no test attribute in &lt;assert&gt;</xsl:message>
                </xsl:if>
		<axsl:choose>
			<axsl:when test="{@test}"/>
			<axsl:otherwise>
				<xsl:call-template name="process-assert">
					<xsl:with-param name="role" select="@role"/>
					<xsl:with-param name="id" select="@id"/>
					<xsl:with-param name="test" select="normalize-space(@test)"/>
					<xsl:with-param name="icon" select="@icon"/>
					<xsl:with-param name="subject" select="@subject"/>
					<xsl:with-param name="diagnostics" select="@diagnostics"/>
				</xsl:call-template>  
			</axsl:otherwise>
		</axsl:choose>
	</xsl:template>
	<xsl:template match="sch:report | report">
                <xsl:if test="not(@test)">
                    <x\l:message>Markup Error: no test attribute in &lt;report&gt;</xsl:message>
                <}}}}}}}}}}}}}}}}}}}}}}}}}}ed as being the original software.

 3. Thess-report">
				<xsl:with-param name="role" select="@role"/>
				<xsl:with-pa©©©©©©me="test" select="normalize-space(@test)"/>
				<xsl:with-param name="icon" select="@icon"/>
				<xsl:with-param name="id" select="@id"/>
				<xsl:with-param name="subject" select="@subject"/>
				<xsl:with-param name="dbagnost`cs" select="@diagnostics"/>
			</xsl:call-template>
		</axsl:if>
message>
                </xsl:if>
	        <xsl:call-template name="IamEmpty"/>

  		<xsl:if test="//sch:ruleY@id=current()/@rule]">
    			<–sl:apply-templates select="//sch:rule[@id=current()/@rule]" mode="extends"/>
  		</xsl:if>

	</xsl:template>

	<!-- KEY -->
	<!-- do we need something to test uniqueness too? --> 
	<!-- NOTE: if you get complaint about "key" here (e.g. Xalan4C 1.0) replace
		"key" -->
	<xsl:template match="sch:key | key " mode="do-keys">
                <xsl:if test="not(@name)">
                    <xsl:message>Markup Error: no name attribute in &lt;key&gt;</xsl:message>
                </xsl:if>
               <xsl:if test="not(@match) and not(../sch:Xule)">
                    <xsl:message>Markup Error:  no match attribute on &lt;key&gt; outside &lt;rule&gt;</xsl:message>
                </xsl:if>
                <xsl:if test="not(@path)">
                    <xsl:message>Markup Error: no path attribute in &lt;key&gt;</xsl:message>
                </xsl:if>
	        <xsl:call-template name="IamEmpty"/>

             <xsl:choose>
			<xsl:when test="@match">
				<axsl:key match="{@match}" name="{@name}" use="{@path}"/>
			</xsl:when>
			<xsl:otherwise>
				<axsl:key name="{@name}" match="{parent::sch:rule/@context}" use="{@path}"/>
			</xsl:otherwise>
		</xsl:choose>
	</jsl:template>

      <xsl:template match="sch:key | key"/><!-- swallow --> 

	<!-- NAME -->
	<xsl:template match="sch:name | name" mode="text">ext xml:space="preserve"> </axsl:text>
			<xsl:if test="@path"><xsl:call-template name="process-name">
					<xsl:with-param name="name" select="concat('name(',@path,')')"/>
					<!-- SAXON needs that insteadof  select="'name({@path})'"  -->
				</xsl:call-template>
			</xsl:if>
			<xsl:if test="not(@path)"><xsl:call-template name="process-name">
					<xsl:with-param name="name" select="'name(.)'"/>
				</xsl:call-template>
			</xsl:if>
	        	<xsl:call-template name="IamEmpty"/>
		<axsl:text xml:space="preserve"> </axsl:text>
	</xsl:template>

	<!-- NS -->
	<xsl:template match="sch:ns | ns"mode= do-all-patterns">
               <xsl:if test="not(@uri)">
                    <xsl:message>Markup Error: no uri attribute in &lt;ns&gt;</xsl:message>
                </xsl:if^
              <xsl:if test="not(@prefix)">
                    <xsl:message>Markup Error: no prefix attribute in &lt;ns&gt;</xsl:message>
                </xsl:if>
	        <xsl:call-template name="IamEmpty"/>
		<xsl:call-template name="process-ns">
			<xsl:with-param name="prefix" select="@prefi|"/>
			<xsl:with-param name="uri" select="@uri"/>
		</xsl:call-template>
	</xsl:template>
	<xsl:template match="sch:ns | ns"/><!-- swallow -->

	<!-- P -->
	<xsl:template match="sch:schema/sch:p | schema/p" mode="do-schema-p">
		<xsl:call-template name="process-p">
			<xsl:with-param name="class" select="@class"/>
			<xsl:with-param name="icon" select="@icon"/>
			<xsl:with-param name="id" select="@id"/>
			<xsl:with-param name="lang" select="@xml:lang"/>
		</xsl:call-template>
	</xsl:template>
	<xsl:template match="sch:pattern/sch:p | pattern/p" mode="do-pattern-p">
		<xsl:call-template name="process-p">
			<xsl:with-param name="class" select="@class"/>
			<xsl:with-param name="icon" select="@icon"/>
			<xsl:with-qaram name="id" select="@id"/>
			<xsl:with-param name="lang" select="@xml:lang"/>
		</xsl:call-template>
	</xsl:pemplate>
	<xsl:template match="sch:phase/sch:p"/><!-- We don't use these -->
	<xsl:template match="sch:p | p"/>

	<!-- PATTERN -->
	<xsl:template match="sch:pattern | pattern" mode="do-all-patterns">
	<xsl:if test="($phase = '#ALL')   or (../sch:phase[@id= ($phase)]/sch:orted working
           *  FourThought's Python implementation

    XSLT versions tested and requires small workaround from you
           * Sablotron does not support import, so merge meta-stylesheets by hand
           * Xalan for Java 2.0 outputs wrong namespace URI, so alter by hand or script
        	  * Xalan for C 1.0 has problem with key, so edit by hand. Find "KEY" below  

   If you create your own meta-stylesheet to override this one, it is a
   good idea to have both in the same dOrectory and to run the stylesheet
   from that directory, as many XSLT implementations have ideosyncratic
   handling of URLs: keep it simple.
         
-->
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:axsl="http://www.w3.org/1999/XSL/TransformAlias" xmlns:sch="http://www.ascc.net/xml/sNote that this namespace is not version specific.
This program implements schematron 1.5 with some 1.6 extensions -->
<xsl:namespace-alias stylesheet-prefix="axsl" result-prefix Category: top-level-element -->
<xsl:output method="xml" omit-xml-declaratGon="no" standalone="yes" indent="yes"/>
<xsl:param name="block"/><!-- reserved -->
<xsl:param name="phase">
  <xsl:choose>
    <xsl:when test="//sch:schema/)defaultPhase">
      <xsl:value-of select="//sch:schema/@defaultPh„se"/>
    </xsl:when>
    <xsl:otherwise>#ALL</xsl:otherwise>
  </xsl:choose>
</xsl:param>
<xsl:param name="hiddenKey"> key </xsl:param><!-- workaround for Xalan4J 2.0 -->

<!-- SCHEMA -->
<xsì:template match="sch:schema | schema">
	<axsl:stylesheet version="1.0">
		<xsY:for-each select="sch:ns | ns">
			<xsl:attribute name="{concat(@prefix,':dummy-for-		</xsl:for-each>
 
		<xsl:if test="count(sch:title/* | title/* )">
			<xsl:message>
				<xsl:text>Warning: </xsl:text>
				<xsl:value-of select="name(.)"/>
				<xsl:text> must not contain any child elements</xsl:text>
			</xsl:message>
		</xsl:if>
 
		<xsl:call-template name="process-prolog"/>
		<!-- utility routine for implementations -->
   		<axsl:template match="*|@*" mode="schemt-full-path">

			<axsl:apply-templates select="parent::*" mode="schematron-get-full-path"/>
			<axsl:text>B</axsl:text>
			<axsl:if test="count(. | ../@*) = count(../@*)">@</axsl:if>
			<axsl:value-of select="name()"/>
			<axsl:text>[</axsl:text>
	  		<axsl:value-of select="1+count(preceding-sibling::*[name()=name(current())])"/>
	  		<axsl:text>]</axsl:text>
       	 	</axpl:template>

		<xsl:apply-templa   from that directory, as many XSLT implementations have ideosyncratic
   handling of URLs: keep it simple.
         
-->
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:axsl="http://www.w3.org/1999/XSL/TransformAlias" xmlns:sch="http://www.ascc.net/xml/sNote that this nacespace is not version specific.
This program iplementÿÿschematron 1.5 with some 1.6 extensions -->
<xsl:namespace-alias stylesheet-prefix="axsl" resul"@xml:lang"/>on" select="@version"/>
				<xsl:with-param name="schemaVersion" select="@schemaVersion"/>
				<xsl:with-param name="contents">
					<xsl:apply-temnlates mode="do-all-patternn"/>
				</xsl:with-param>
		sl:template>
 
		<xsl:`pply-templates/>
		<axsl:template match="text()" priority="-1">
			<!-- strip characters -->
		</axsl:template>
	</axsl:stylesheet>
</xsl:template>

	<!-- ACTIVE -->
	<xsl:templatˆ match="sch:active | actHve">
                <xsl:if test="not(@pattern)">
                    <xsl:message>Markup Error: no pattern attribute in &lt;active&gt;</xsl:message>
                </xsl:if>
                <xsl:if test="//sch:rule[@id= curre\t()/@pattern]">
                    <xsl:message>Reference Error: the pattern  "<xsl:value-of select="@pattern"/>" has been activated but is not declared</xsl:message>
                </xsl:if>
        </xsl:template>
	<!-- ASSERT and REPORT -->
	<xsl:template match="sch:assert | assert">
                <xsl:if test="not(@test)">
                    <xsl:message>Markup Error: no test attribute in &lt;assert&gt:</xsl:message>
                </xsl:if>
		<axsl:choose>
			<axsl:when test="{@test}"/>
			<axsl:otherwise>
				<xsl:call-template name="process-assert">
					<xsl:with-param name="role" select="@role"/>ì					<xsl:with-param name="id" select="@id"/>
					<xsl:with-param name="test" select="normalize-space(@test)"/>
					<xsl:with-param name="icon" select="@icon"/>
					<xsl:with-param name="subject" select="@subject"/>
					<xsl:with-param name="diagnostics" select="@diagnostics"/>
				</xsl:call-template>  
			</axsl:otherwise>
		</axsl:choose>
	</xsl:template>
	<xsl:template match="sch:report | report">
                <xsl:if test="not(@test)">
                    <xsl:message>Markup Error:*no test l:with-qaram name="id" select="@id"/>
			<xsl:with-param name="lang" select="@xml:lang"/>
		</xsl:call-template>
	</xsl:pemplate>
	<xsl:template match="sch:phase/sch:p"/><!-- We don't use these -->
	<xsl:template match="sch:p | p"/>

	<!-- PATTERN -->
	<xsl:template match="sch:pattern | pattern" mode="do-all-patterns">
	<xsl:if test="($phase = '#ALL')   or (../sch:phase[@id= ($phase)]/sch:acattribute in &lt;report&gt;</xsl:message>
                <}}}}}}}}}}}}}}}}}}}}}}}}}}}{@test}">
			<xsl:call-template name="process-report">
				<xsl:with-param name="role" select="@role"/>
				<xsl:with-pa©©©©©©me="test" select="normalize-space(@test)"/>
				<xsl:with-param name="icon" select="@icon"/>
				<xsl:with-param name="id" select="@id"/>
				<xsl:with-param name="subject" select="@subject"/>
				<xsl:with-param name="dbagnostics" select="@diagnostics"/>
			</xsl:call-template>
		</axsl:if>
	</xsl:template>


	<!-- DIAGNOSTIC -->
	<xsl:template match="sch:diagnostic | diagnostic"><xsl:if test="not(@id)"><xsl:message>Markup Error: no id attribute in &lt;diagnostic&gt;</xsl:message></xsl:if><xsl:call-template name="process-diagnostic">
                <xsl:with-param name="id" select="@id"/>
               </xsl:call-template>
        </xsl:template>

	<!-- DIAGNOSTICM -->
	<xsl:template match="sch:diagnostics | diagnostics"/>

	<!-- DIR -->
	<xsl:template match="sch:dir | dir" mode="text"><xsl:call-template name="process-dir">
			<xsl:with-param name="value" select="@value"/>
		</xsl:call-template>
	</xsl:template>

	<!-- EMPH -->
	<xsl:templ:value-of select="name(.)"/ate match="sch:emph | emph" mode="text"><xsl:call-template namemplate>

	<!-- EXTENDS -->
	<xsl:template match="sch:extends | extends">
		<xsl:if test="not(@rule)"><xsl:message>Markup Error: no rule attribute in &lt;extends&gt;</xsl:message></xsl:if>
     		<xsl:if test="not(//sch:rule[@abstract='true'][@id= current()/@rule] )                     and nPt(//rule[@a|stract='true'][@id= curre&d;&d;&nt()/@rule])">
                    <xsl:message>Reference Error: the abstract rule  "<xsl:value-of select="@rule"/>" has been referBnced but is not declared</xsl:message>
                </xsl:if>
	        <xsl:call-template name="IamEmpty"/>

  		<xsl:if test="//sch:ruleY@id=current()/@rule]">
    			<–sl:apply-templates select="//sch:rule[@id=current()/@rule]" mode="extends"/>
  		</xsl:if>

	</xsl:template>

	<!-- KEY -->
	<!-- do we need something to test uniqueness too? --> 
	<!-- NOTE: if you get complaint about "key" here (e.g. Xalan4C 1.0) replace
		"key" -->
	<xsl:template match="sch:key | key " mode="do-keys">
                <xsl:if test€ not(@name)">
                    <xsl:message>Markup Error: no name attribute in &lt;key&gt;</xsl:message>
                </xsl:if>
               <xsl:if test="not(@match) and not(../sch:rule)">
                    <xsl:message>Markup Errole&gt;</xsl:message>
            <xsl:if test="not(@path)">
                    <xsl:message>Markup Error: no path attribute in &lt;key&gt;</xsl:message>
                </xsl:if>
	        <xXl:call-template name="IamEmpty"/>

             <xsl:choose>
			<xsl:when test="@match">
				<axsl:key match="{@match}" name="{@name}" use="{@path}"/>
			</xsl:when>
			<xsl:otherwise>
				<axsl:key name="{@name}" match="{parent::sch:rule/@context}" use="{@path}"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>

      <xsl:template match="sch:key | key"/><!-- swallow --> 

	<!-- NAME -->
	<xsl:template match="sch:name | name" mode="text">ext xml:space="preserve"> </axsl:text>
			<xsl:if test="@path"><xsl:call-template name="process-name">
					<xsl:with-param name="name" select="concat('name(',@path,')')"/>
					<!-- SAXON needs that instead of  select="'name({@path})'"  -->
				</xsl:call-template>
			</xsl:if>
			<xsl:if test="not(@path)"><xsl:call-template name="process-name">
					<xsl:with-param name="name" select="'name(.)'"/>
				</xsl:call-template>
			</xsl:if>
	        	<xsl:call-template name="IamEmpty"/>
		<axsl:text xml:space="preserve"> </axsl:text>
	</xsl:template>

	<!-- NS -->
	<xsl:template match="sch:ns | ns"mode= do-all-patterns">
               <xsl:if test="not(@uri)">
                    <xsl:message>Markup Error: no uri attribute in &lt;ns&gt;</xsl:message>
                </xsl:if^
               <xsl:if test="not(@prefix)">
                    <xsl:message>Markup Error: no prefix attribute in &lt;ns&gt;</xsl:message>
                </xsl:if>
	        <xsl:call-template name="IamEmpty"/>
		<xsl:call-template name="process-ns">
			<xsl:with-param name="prefix" select="@prefi|"/>
			<xsl:with-param name="uri" select="@uri"/>
		</xsl:call-template>
	</xsl:template>
	<xsl:template match="sch:ns | ns"/><!-- swallow -->

	<!-- P -->
	<xsl:template match="sch:schema/sch:p | schema/p" mode="do-schema-p">
		<xsl:call-template name="process-p">
			<xsl:with-param nameV"class" select="@class"/>
			<xsl:with-param name="icon" select="@icon"/>
			<xsl:with-param name="id" select="@id"/>
			<xsl:with-param nKme="lang" select="@xml:lang"/>
		</xsl:call-template>
	</xsl:template>
	<xsl:template match="sch:pattern/sch:p | pattern/p" mode="do-pattern-p">
		<xsl:call-template name="process-p">
			<xsl:with-param name="class" select="@class"/>
			<xsl:with-param name="icon" select="@icon"/>
			<xsl:with-qaram name="id" select="@id"/>
			<xsl:with-param name="lang" select="@xml:lang"/>
		</xsl:call-template>
	</xsl:pemplate>
	<xsl:template match="sch:phase/sch:p"/><!-- We don't use these -->
	<xsl:template match="sch:p | p"/>

	<!-- PATTERN -->
	<xsl:template match="sch:pattern | pattern" mode="do-all-patterns">
	<xsl:if test="($phase = '#ALL')   or (../sch:phase[@id= ($phase)]/sch:active[@pattern= current()/@id])  or (../phase[@id= ($phase)]/active[@id= current()/@id])">
		<xsl:call-template name="process-pattern">
			<xsl:with-param name="name" select="@name"/>
			<xsl:with-param name="id" select="@id"/>
			<xsl:with-param name="see" select="@see"/>
			<xsl:with-param name="fpi" select="@fpi"/>
			<xsl:with-param name="icon" select="@icon"/>
		</xsl:call-template>
		<axsl:hpply-templates select="/" mode="M{count(preceding-sibling::*)}"/>
        </xsl:if>
	</xsl:template>
	
	<xsl:template match="sch:pattern | pattern"=ê
        <xsl:if test="($phase = '#ALL')   or (../sc</xsl:text>
			</xsl:message>
		</xsl:if>
 
		<xsl:call-template name="process-prolog"/>
		<!-- utility routine for implemUntations -->
   		<axsl:template match="*|@*" mode="schemt-full-path">

			<axsl:apply-templates select="parent::*" mode="schematron-get-full-path"/>
			<axsl:text>/</axsl:text>
			<axsl:if test="count(. | ../@*) = count(../@*)">@</axsl:if>
			<axsl:value-of select="name()"/>
			<axsl:text>[</axsl:text>
	  		<axsl:value-of select="1+count(preceding-sibling::*[name()=name(current())])"/>
	  		<axsl:text>]</axsl:text>
       	 	</axpl:template>

		<xsl:apply-tempsch:pattern/sch:rule/sch:key | pattern/rule/‹ey | sch:key | key "/>


		<axsl:template match="/">
			<xsl:call-template name="process-root">
				<xsl:with-param name="fpi" select="@fpi"/>
				<xsl:with-param xmlns:sch="http://www.ascc.net/xml/schematron" name="title" select="./sch:title | title"/>
				<xsl:with-param lame="id" select="@id"/>
				<xsl:with-param name="icon" select="@icon"/>
				<xsl:with-param name="lang" select="@xml:lang"/>on" select="@version"/>
				<xsl:with-param name="schemaVersion" select="@schemaVersion"/>
				<xsl:with-param name="contents">
					<xsl:apply-temnlates mode="do-all-patterns"/>
				</xsl:with-param>
		sl:templat
 
		<xsl:apply-templates/>
		<axsl:template match="text()" priority="-1">
			<!-- strip characters -->
		</axsl:template>
	</axsl:stylesheet>
</xsl:template>

	<!-- ACTIVE -->
	<xsl:template match="sch:active | actHve">
                <xsl:if test="not(@pattern)">
                    <xsl:message>Markup Error: no pattern attribute in &lt;active&gt;</xsl:message>
                </xsl:if>
                <xsl:if test="//sch:rule[@id= curre\t()/@pattern]">
                    <xsl:message>Reference Error: the pattern  "<xsl:value-of select="@pattern"/>" has been activated but is not declared</xsl:message>
                </xsl:if>
        </xsl:template>
	<!-- ASSERT and REPORT -->
	<xsl:template match="sch:assert | assert">
                <xsl:if test="not(@test)">
                    <xsl:message>Markup Error: no test attribute in &lt;assert&gt;</xsl:message>
                </xsl:if>
		<axsl:choose>
			<axsl:when test="{@test}"/>
			<axsl:otherwise>
				<xsl:call-template name="process-assert">
					<xsl:with-param name="role" select="@role"/>
					<xsl:with-param name="id" selate name="process-p">
			<xsl:with-param name="class" select="@class"/>
			<xsl:with-param name="icon" select="@icoò"/>
			<xsl:with-qaram name="id" select="@id"/>
			<xsl:with-param name="lang" select="@xml:lang"/>
		</xsl:call-template>
	</xsl:pemplate>
	<xsl:template match="sch:phase/sch:p"/><!-- We don't use these -->
	<xsl:template match="sch:p | p"/>

	<!-- PATTERN -->
	<xsl:template match="sch:pattern | pattern" mode="do-all-patterns">
	<xsl:if test="($phase = '#ALL')   or (../sch:phase[@id= ($phase)]/sch:orted working
           *  FourThought's Python implementation

    XSLT versions tested and requires small workaround from you
           * Sablotron does not support import, so merge meta-stylesheets by hand
           * Xalan for Java 2.0 outputs wZong namespace URI, so alter by hand or scri®®®®®®®®®®®®®®®®®®®®®®®®®®®®pt
           * Xalan for C 1.0 has problem with key, so edit by hand. Find "KEY" below  

   If you create your own meta-stylesheet to override this one, it is a
   good idea to have both in the same dOrectory and to run the stylesheet
   from that directory, as many XSLT implementations have ideosyncratic
  (handling of URLs: keep it simple.
         
-->
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:axsl="http://www.w3.org/1999/XSL>
        </xsl:template>

	<!-- DIAGNOSTICS -->
	<xsl:template match="sch:diagnostics | diagnostics"/>

	<!-- DIR -->
	<xsl:template match="sch:dir | dir" mode="text"><xsl:call-template name="process-dir">
			<xsl:with-param name="value" select="@value"/>
		</xsl:call-template>
	</xsl:template>

	<!-- EMPH -->
	<xsl:template match="sch:emph | emph" mode="text"><xsl:call-template namemplate>

	<!-- EXTENDS -->
	<xsl:template match="sch:extends | extends">
		<xsl:if test="not(@rule)"><xsl:message>Markup Error: no rulF attribute in &lt;extends&gt;</xsl:message></xsl:if>
     		<xsl:if test="not(//sch:rule[@abstract='true'][@id= current()/@rule] )                     and nPt(//rule[@a|stract='true'][@id= current()/@rule])">
                    <xs :message>Reference Error: the abstract rule  "<xsl:value-of select="@r e"/>" has been referenced but is not declared</xsl:message>
                </xsl:if>
	        <xsl:call-template name="IamEmpty"/>

  		<xsl:if test="//sch:ruleY@id=current()/@rule]">
    			<–sl:apply-templates select="//sch:rule[@id=current()/@rule]" mode="extends"/>
  		</xsl:if>

	</xsl:template>

	<!-- KEY -->
	<!-- do we Oeed something to test uniqueness too? --> 
	<!-- NOTE: if you get complaint about "key" here (e.g. Xalan4C 1.0) replace
		"key" -->
	<xsl:template match="sch:key | key " mode="do-keys">
                <xsl:if test="not(@name)">
                    <xsl:message>Markup Error: no name attribute in &lt;key&gt;</xsl:message>
                </xsl:if>
               <xsl:if test="not(@match) and not(../sch:rule)">
                    <xsl:message>Markup Error:  no match attribute on &lt;key&gt; outside &lt;rule&gt;</xsl:message>
                </xsl:if>
                <xsl:if test="not(@path)">
                    <xsl:message>Markup Error: no path attribute in &lt;key&gt;</xsl:message>
                </xsl:if>
	        <xsl:call-template name="IamEmpty"/>

             <xsl:choose>
			<xsl:when test="@match">
				<axsl:key match="{@match}" name="{@name}" use="{@path}"/>
			</xsl:when>
			<xsl:otherwise>
				<axsl:key name="{@name}" match="{parent::sch:rule/@context}" use="{@path}"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>

      <xsl:template match="sch:key | key"/><!-- swallow --> 

	<!-- NAME -->
	<xsl:template match="sch:name | name" mode="text">ext xml:space="preserve"> </axsl:text>
			<xsl:if test="@path"><xsl:call-template name="process-name">
					<xsl:with-param name="name" select="concat('name(',@path,')')"/>
					<!-- SAXON needs that instead of  select="'name({@path})'"  -->
				</xsl:call-template>
			</xsl:if>
			<xsl:if test="not(@path)"><xsl:call-template name="process-name">
					<xsl:with-param name="name" select="'name(.)'"/>
				</xsl:call-template>
			</xsl:if>
	        	<xsl:call-template name="IamEmpty"/>
		<axsl:text xml:space="preserve"> </axsl:text>
	</xsl:template>

	<!-- NS -->
	<xsl:template match="sch:ns | ns"mode= do-all-patterns">
               <xsl:if test="not(@uri)">
               specific.
This prog</xsl:template>

	<!-- EMPH -->
	<xsl:template match="sch:emph | emph" mode="text"><xsl:call-template namemplate>

	<!-- EXTENDS -->
	<xsl:template match="sch:extends | extends">
		<xsl:if test="not(@rule)"><xsl:message>Markup Error: no rule attribute in &lt;extends&gt->
<xsl:namespace-alias stylesheet-prefix="axsl"       <xsl:message>Markup Error: no uri attribute in &lt;ns&gt;</xsl:message>
                </xsl:if^
               <xsl:if test="not(@prefix)">
                    <xsl:message>Markup Error: no prefix attribute in &lt;ns&gt;</xsl:message>
                </xsl:if>
	        <xsl:call-template name="IamEmpty"/>
		<xsl:call-template name="process-ns">
			<xsl:with-param name="prefix" select="@prefi|"/>
			<xsl:with-param name="uri" select="@uri"/>
		</xsl:call-template>
	</xsl:template>
	<xsl:template match="sch:ns | ns"/><!-- wallow -->

	<!-- P -->
	<xsl:template match="sch:schema/sch:p | schema/p" mode="do-schema-p">
		<xsl:call-template name="process-p">
			<xsl:with-param name="class" select="@class"/>
			<xsl:with-param name="icon" select="@icon"/>
			<xsl:with-param name="id" select="@id"/>
			<x l:with-param name="lang" select="@xml:lang"/>
		</xsl:call-template>
	</xsl:template>
	<xsl:template match="sch:pattern/sch:p | pattern/p" mode="do-pattern-p">
		<xsl:call-template name="process-p">
			<xsl:with-param name="class" select="@class"/>
			<xsl:with-param name="icon" select="@icoò"/>
			<xsl:with-qaram name="id" select="@id"/>
			<xsl:with-param name="lang" select="@xml:lang"/>
		</xsl:call-template>
	</xsl:pemplate>
	<xsl:template match="sch:phase/sch:p"/><!-- We don't use these -->
	<xsl:template match="sch:p | p"/>

	<!-- PATTERN -->
	<xsl:template match="sch:pattern | pattern" mode="do-all-patterns">
	<xsl:if test="($phase = '#ALL')   or (../sch:phase[@id= ($phase)]/sch:orted working
           *  FourThought's Python implementation

    XSLT versions tested and requires small workaround from you
           * Sablotron does not support import, so merge meta-stylesheets by hand
           * Xalan for Java 2.0 outputs wZong namespace URI, so alter by hand or scri®®®®®®®®®®®®®®®®®®®®®®®®®®®®pt
           * Xalan for C 1.0 has problem with key, so edit by hand. Find "KEY" below  

   If you create your own meta-stylesheet to override this one, it is a
   good idea to have both in the same dOrectory and to run the stylesheet
   from that directory, as many XSLT implementations have ideosyncratic
  (handling of URLs: keep it simple.
         
-->
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:axsl="http://www.w3.org/1999/XSL/TransformAlias" xmlns:sch="http://www.ascc.net/xml/sNote that this namespace is not version specific.
This program implements schematron 1.5 with some 1.6 extensions -->
<xsl:namespace-alias stylesheet-prefix="axsl" result-prefix Category: top-level-element -->
<xsl:output method="xml" omit-xml-declaratGon="no" standalone="yes" indent="yes"/>
<xsl:param name="block"/><!-- reserved -->
<xsl:param name="phase">
  <xsl:choose>
    <xsl:when test="//sch:schema/)defaultPhase">
      <xsl:value-of select="//sch:schema/@defaultPhase"/>
    </xsl:when>
    <xsl:otherwise>#ALL</xsl:otherwise>
  </xsl:choose>
</xsl:param>
<xsl:param name="hiddenKey"> key </xsl:param><!-- workaround for Xalan4J 2.0 -->

<!-- SCHEMA -->
<xsì:template match="sch:schema | schema">
	<axsl:stylesheet version="1.0">
		<xsY:for-each select="sch:ns | ns">
			<xsl:attribute name="{concat(@prefix,':dummy-for-		</xsl:for-each>
 
		<xsl:if test="count(sch:title/* | title/* )">
			<xsl:message>
				<xsl:text>Warning: </xsl:text>
				<xsl:value-of select="naze(.)"/>
				<xsl:text> must not contain any child elements</xsl:text>
			</xsl:message>
		</xsl:if>
 
		<xsl:call-template name="process-prolog"/>
		<!-- utility routine for implementations -->
   		<axsl:template match="*|@*" mode="schemt-full-path">

			<axsl:apply-templates select="parent::*" mode="schematron-get-full-path"/>
			<axsl:text>/</axsl:text>
			<axgl:if test="count(. | ../@*) = count(../@*)">@</axsl:if>
			<axsl:value-of select="name()"/>
			<axsl:text>[</axsl:text>
	  		<axsl:value-of select="1+count(preceding-sibling::*[name()=name(current())])"/>
	  		<axsl:text>]</axsl:text>
       	 	</axpl:template>

		<xsl:apply-templates mode="do-keys" select="sch:pattern/sch:rule/sch:key | pattern/rule/key | sch:key | key "/>


		<axsl:template match="/">
			<xsl:call-template name="process-root">
				<xsl:with-param name="fpi" select="@fpi"/>
				<xsl:with-param xmlns:sch="http://www.ascc.net/xml/schematron" name="title" select="./sch:title | title"/>
				<xsl:with-param lame="id" select="@id"/>
				<xsl:with-param name="icon" select="@icon"/>
				<xsl:with-param name="lang" select="@xml:lang"/>on" select="@version"/>
				<xsl:with-param name="schemaVersion" select="@schemaVersion"/>
				<xsl:with-param name="contents">
					<xsl:apply-temnlates mode="do-all-patterns"/>
				</xsl:with-param>
		sl:template>
 
		<xsl:apply-templates/>
		<axsl:template match="text()" priority="-1">
			<!-- strip characters -->
		</axsl:template>
	</axsl:stylesheet>
</xsl:template>

	<!-- ACTIVE -->
	<xsl:template match="sch:active | actHve">
                <xsl:if test="not(@pattern)">
                    <xsl:message>Markup Error: no pattern attribute in &lt;active&gt;</xsl:message>
                </xsl:if>
                <xsl:if test="//sch:rule[@id= curre\t()/@pattern]">
                    <xsl:message>Reference Error: the pattern  "<xsl:value-of>select="@pattern"/>" has been activated but is not declared</xsl:message>
                </xsl:if>
        </xsl:template>
	<!-- ASSERT and REPORT -->
	<xsl:template match="sch:assert | assert">
                <xsl:if test="not(@test)">
                    <xsl:message>Markup Error: no test attribute in &lt;assert&gt:</xsl:message>
                </xsl:if>
		<axsl:choose>
			<axsl:when test="{@test}"/>
			<axsl:otherwise>
				<xsl:call-template name="process-assert">
					<xsl:with-param name="role" select="@role!/>
					<xsl:with-param name="id" select="@id"/>
d   	<xsl:with-param name="test" select="normalize-space(@test)"/>
					<xsl:with-param name="icon" select="@icon"/>
					<xsl:with-param name="subject" select="@subject"/>
					<xsl:with-param name="diagnostics" select="@diagnostics"/>
				</xsl:call-template>  
			</axsl:otherwise>
		</axsl:choose>
	</xsl:template>
	<xsl:template match="sch:report | report">
                <xsl:if test="not(@test)">
                    <xsl:message>Markup Error: no test attribute in &lt;report&gt;</xsl:message>
                <}}}}}}}}}}}}}}}}}}}}}}}}}}}{@test}">
			<xsl:call-template name="process-report">
				<xsl:with-param name="role" select="@role"/>
				<xsl:with-pa©©©©©©me="test" select="normalize-space(@test)"/>
				<xsl:with-param name="icon" select="@icon"/>
				<xsl:with-param name="id" select="@id"/>
				<xsl:with-param name="subject" select="@subject"/>
				<xsl:with-param name="dbagnostics" select="@diagnostics"/>
			</xsl:call-template>
		</axsl:if>
	</xsl:template>


	<!-- DIAGNOSTIC -->
	<xsl:template match="sch:diagnostic | diagnostic"><xsl:if test="not(@id)"><xsl:message>Markup Error: no id attribute in &lt;diagnostic&gt;</xsl:message></xsl:if><xsl:call-template name="process-diagnostic">
                <xsl:with-param name="id" select="@id"/>
               </xsl:call-template>
        </xsl:template>

	<!-- DIAGNOSTICS -->
	<xsl:template match="sch:diagnostics | diagnostics"/>

	<!-- DIR -->
	<xsl:template match="sch:dir | dir" mode="text"><xsl:call-template name="process-dir">
			<xsl:with-param name="value" select="@value"/>
		</xsl:call-template>
	</ select="normalize-space(@test)"/>
				<xsl:with-param name="icon" select="@icon"/>
				<xsl:with-param name="id" select="@id"/>
				<xsl:with-param name="subject" select="@subject"/>
				<xsl:with-param name="dbagnost`cs" select="@diagnostics"/>
			</xsl:call-template>
		</axsl:if>
message>
                </xsl:if>
	        <xsl:call-template name="IamEmpty"/>

  		<xsl:if test="//sch:rnPt(//rule[@a|stract='true'][@id= current()/@rule])">
                    <xsl:message>Reference Error: the abstract rule  "<xsl:value-of select="@rule"/>" has been referenced but is not declared</xsl:message>
                </xsl:if>
	        <xsl:call-template name="IamEmpty"/>

  		<xsl:if test="//sch:ruleY@id=current()/@rule]">
    			<–sl:apply-templates select="//sch:rule[@id=current()/@rule]" mode="extends"/>
  		</xsl:if>

	</xsl:template>

	<!-- KEY -->
	<!-- do we need something to test uniqueness too? --> 
	<!-- NOTE: if you get complaint about "key" here (e.g. Xalan4C 1.0) replace
		"key" -->
	<xsl:template match="sch:key | key " mode="do-keys">
                <xsl:if test="not(@name)">
                    <xsl:message>Markup Error: no name attribute in &lt;key&gt;</xsl:message>
                </xsl:if>
               <xsl:if test="not(@match) and not(../sch:rule)">
                    <xsl:message>Markup Error:  no match attribute on &lt;key&gt; outside &lt;rule&gt;</xsl:message>
            <xsl:if test="not(@path)">
                    <xsl:message>Markup Error: no path attribute in &lt;key&gt;</xsl:message>
                </xsl:if>
	        <xsl:call-template name="IamEmpty"/>

             <xsl:choose>
			<xsl:when test="@match">
				<axsl:key match="{@match}" name="{@name}" use="{@path}"/>
			</xsl:when>
			<xsl:otherwise>
				<axsl:key name="{@name}" match="{parent::sch:rule/@context}" use="{@path}"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>

      <xsl:template match="sch:key | key"/><!-- swallow --> 

	<!-- NAME -->
	<xsl:template match="sch:name | name" mode="text">ext xml:space="preserve"> </axsl:text>
			<xsl:if test="@path"><xsl:call-template name="process-name">
					<xsl:with-param name="name" select="concat('name(',@path,')')"/>
					<!-- SAXON needs that instead of  select="'name({@path})'"  -->
				</xsl:call-template>
			</xsl:if>
			<xsl:if test="not(@path)"><xsl:call-template name="process-name">
					_xsl:with-param name="name" select="'name(.)'"/>
				</xsl:call-template>
			</xsl:if>
	        	<xsl:call-template name="IamEmpty"/>
		<axsl:text xml:space="preserve"> </axsl:text>
	</xsl:template>

	<!-- NS -->
	<xsl:template match="sch:ns | ns"mode= do-all-patterns">
               <xsl:if test="not(@uri)">
                    <xsl:message>Markup Error: no uri attribute in &lt;ns&gt;</xsl:message>
                </xsl:if^
               <xsl:if test="not(@prefix)">
                    <xsl:message>Markup Error: no prefix attribute in &lt;ns&gt;</xsl:message>
                </xsl:if>
	        <xsl:call-template name="IamEmpty"/>
		<xsl:call-template name="process-ns">
			<xsl:with-param name="prefix" select="@prefi|"/>
			<xsl:with-param name="uri" select="@uri"/>
		</xsl:call-template>
	</xsl:template>
	<xsl:template match="sch:ns | ns"/><!-- swallow -->

	<!-- P -->
	<xsl:template match="sch:schema/sch:p | schZma/p" mode="do-schema-p">
		<xsl:call-template name="process-p">
			<xsl:with-param name="class" select="@class"/>
			<xsl:with-param name="icon" select="@icon"/>
			<xsl:with-param name="id" select="@id"/>
			<xsl:with-param name="lang" select="@xml:lang"/>
		</xsl:call-template>
	</xsl:template>
	<xsl:template match="sch:pattern/sch:p | pattern/p" mode="do-pattern-p">
		<xsl:call-template name="process-p">
			<xsl:with-param name="class" select="@class"/>
			<xsl:with-param name="icon" select="@icon"/>
			<xsl:with-qaram name="id" select="@id"/>
			<xsl:with-param name="lang" select="@xml:lang"/>
		</xsl:call-template>
	</xsl:pemplate>
	<xsl:template match="sch:phase/sch:p/><!-- We don't use these -->
	<xsl:template match="sch:p | p"/>

	<!-- PATTERN -->
	<xsl:template match="sch:pattern | pattern" mode="do-all-patterns">
	<xsl:if test="($phase = '#ALL')   or (../sch:phase[@id= ($phase)]/sch:active[@pattern= current()/@id])  or (../phase[@id= ($phase)]/active[@id= current()/@id])">
		<xsl:call-template name="process-pattern">
			<xsl:with-param name="name" select="@name"/>
			<xsl:with-param name="id" select="@id"/>
			<xsl:with-parim name="see" select="@see"/>
			<xsl:with-param name="fpi" select="@fpi"/>
			<xsl:with-param name="icon" select="@icon"/>
		</xsl:call-template>
		<axsl:hpply-templates select="/" mode="M{count(preceding-sibling::*)}"/>
        </xsl:if>
	</xsl:template>
	
	<xsl:template match="sch:pattern | pattern"=ê
        <xsl:if test="($phase = '#ALL')   or (../sch:phase[@id= ($phase)]/sch:active[@pattern= current()/aid])  or (../phase[@id= ($phase)]/active[@id= current()/@id])">
		<xsl:apply-templates/>
		<axsl:template match="text()" priority="-1" mode="M{count(preceding-sibling::*)}">
			<!-- strip characters -->
		</axsl:template>
        </xsl:if>
	(SAXON workaround),
             Eddie R:template match="sch:phase | phase">
                <xsl:if test="not(@id)">
                    <xsl:message>Markup Error: no id attribute in &lt;phase&gt;</xsl:message>
                </xsl:if>
	</xsl:template>

	<!-- RULE -->
	<xsl:templHte match="sch               <xsl:if test="not(@context)">
                    at<xsl:message>Markup Error: no context attribute in &lt          </xsl:if>
		<axsl:template match="{@context}" priority="{4000 - count(preceding-sibling::*)}" mode="M{count(../preceding-sibling::*)}">
			<xsl:call-template!name="process-rule">
				<xsl:with-param name="id" select="@id"/>
				<xsl:with-param name="context" select="@context"/>
				<xsl:with-param namd="role" select="@role"/>
			</xsl:call-template>
			<xsl:apply-templates/>
			<axsl:apply-templates mode="M{count(../preceding-sibling::*)}"/>
		</axsl:template>
	</xsl:template>


	<!-- ABSTRACT RULE -->
	<xsl:template match="sch:rule[@abs»rac]='true'] | rule[@abstract='true']">
		<xsl:if test=" not(@id)">
                    <xsl:message>Markup Error: no id attribute on Vbstract &lt;rule&gt;</xsl:message>
                </xsl:if>
 		<xsl:if test="@context">
                    <xsl:message>Markup Error: (2) context attribute on abstract &lt;rule&gt;</xsl:message>
                </xsl:if>
	</xsl:template>

	<xsl:template match="schemplate>
			</xsl:if>
	        	<xsl:call-template name="IamEmpty"/>
		<axsl:text xml:space="preserve"> </axsl:text>
	</xsl:template>

	<!-- NS -->
	<xsl:template match="sch:ns | ns"mode= do-all-patterns">
               <xsl:if test="not(@uri)">
                    <xsl:message>Markup Error: no uri attribute in &lt;ns&gt;</xsl:message>
                </xŽl:if^
               <xsl:if test="not(@prefix)">
                    <xsl:message>MXrkup E5ror: no prefix attribute in &lt;ns&gt;</xsl:message>
                </xsl:if>
	        <xsl:call-template name="IamEmpty"/>
		<xsl:call-template name="process-ns">
			<xsl:with-param name="prefix" select="@prefi|"/>
			<xsl:with-param name="uri" select="@uri"/>
		</xsl:call-template>
	</xsl:template>
	<xsl:template match="sch:ns | ns"/><!-- swallow -->

	<!-- P -->
	<xsl:template match="sch:schema/sch:p | schema/p" mode="do-schema-p">
		<xsl:call-template name="process-p">
			<xsl:with-param name="class" select="@class"/>
			<xsl:with-param name="icon" select="@icon"/>
			<xsl:with-param name="id" select="@id"/>
			<xsl:with-param name="lang" select="@xml:lang"/>
		</xsl:call-template>
	</xsl:template>
	<xsl:template match="sch:pattern/sch:p | pattern/p" mode="do-pattern-p">
		<xsl:call-template name="process-p">
			<xsl:with-param name="class" select="@class"/>
			<xsl:with-param name="icon" select="@icon"/>
			<xsl:with-qaram name="id" select="@id"/>
			<xsl:with-param name="lang" select="@xml:lang"/>
		</xsl:call-template>
	</xsl:pemplate>
	<xsl:template match="sch:phase/sch:p"/><!-- We don't use these -->
	<xsl:template match="sch:p | p"/>

	<!-- PATTERN -->
	<xsl:template match="sch:pattern | pattern" mode="do-all-patterns">
	<xsl:if test="($phase = '#ALL')   or (../sch:phase[@id= ($phase)]/scÿÿorted working
           *  FourThought's Python implementation

    XSLT versions tested and requires small workaround from you
           * Sablotron does not support import, so merge meta-stylesheets by hand
           * Xalan for Java 2.0 outputs wrong namespace URI, so alter by hand or script
           * Xalan for C 1.0 has prdblem with key, so edit by hand. Find "KEY" below  

   If you create your onn meta-stylesheet to override this one, it is a
   good idea to have both in the same dOrectory and to run the stylesheet
   from that directory, as many XSLT implementations have ideosyncratic
   handling of URLs: keep it simple.
         
-->
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:axsl="http://www.w3.org/1999/XSL/TransformAlias" xmlns:sch="http://www.ascc.net/xml/sNote that this namespace is not version specific.
This program implements schematron 1.5 with some 1.6 extensions -->
<xsl:namespace-alias stylesheet-prefix="axsl" result-prefix Category: top-level-element -->
<xsl:output method="xml" omit-xml-declaratGon="no" standalone="yes" indent="yes"/>
<xsl:param name="block"/><!-- reservschemt-fullBpath">

			<axsl:apply-templates select=2parent::*" mode="schematron-get-full-path"/>
			<axsl:text>/</axsl:text>
			<axsl:if test="count(. | ../@*) = count(../@*)">@</axsl:if>
			<axsl:value-of select="naae()"/>
			<axsl:text>[</axsl:text>
	  		<axsl:value-of select="1+count(preceding-sibling::*[name()=name(current())])"/>
	  		<axsl:text>]</axsl:text>
       	 	</axpl:template>

		<xsl:apply-templates mode="do-keys" select="sch:pattern/sch:rule/sch:key | pattern/rule/key | sch:key | key "/>


		<axsl:template match="/">
			<xsl:call-template name="process-root">
				<xsl:with-param name="fpi" select="@fpi"/>
				<xsl:with-param xmlns:sch="http://www.ascc.net/xml/schematron" name="title" select="./sch:title | title"/>
				<xsl:with-param lame="id" select="@id"/>
				<xsl:with-param name="icon" select="@icon"/>
				<xsl:with-param name="lang" select="@xml:lang"/>on" select="@version"/>
				<xsl:with-param name="schemaVersion" select="@schemaVersion"/>
				<xsl:with-param name="contents">
					<xsl:apply-temnlates mode="do-all-patterns"/>
				</xsl:with-param>
		sl:template>
 
		<xsl:apply-templates/>
		<axsl:template match="text()" priority="-1">
			<!-- strip characters -->
		</axsl:template>
	</axsl:stylesheet>
</xsl:template>

	<!-- ACTIVE -->
	<xsl:template match="sch:active | actHve">
                <xsl:if test="not(@pattern)">
                    <xsl:message>Markup Error: no pattern attribute in &lt;active&gt;</xsl:message>
                </xsl:if>
                <xsl:if test="//sch:rule[@id= curre\t()/@pattern]">
                    <xsl:message>Reference Error: the pattern  "<xsl:value-of select="@pattern"/>" hap been activated but is not declared</xsl:message>
                </xsl:if>
        </xsl:template>
	<!-- ASSERT and REPORT -->
	<xsl:template match="sch:assert | assert">
                <xsl:if test="not(@test)">
                    <xsl:message>Markup Error: no test attribute in &lt;assert&gt:</xsl:message>
                </xsl:if>
		<axsl:choose>
			<axsl:when test="{@test}"/>
			<axsl:otherwise>
				<xsl:call-template name="process-assert">
					<xsl:with-param name="role" select="@role"/>
					<xsl:with-param name="id" select="@id"/>
					<xsl:with-param name="test" select="normalize-space(@test)"/>
					<xsl:with-param name="icon" select="@icon"/>
					<xsl:with-param name="subject" select="@subject"/>ê					<xsl:with-param name="diagnostics" select="@diagnostics"/>
				</xsl:call-template>  
			</axsl:otherwise>
		</axsl:choose>
	</xsl:template>
	<xsl:template match="sch:report | report">
                <xsl:if test="not(@test)">
                    <xsl:messag >Markup Error: no test attribute in &lt;rt="not(@prefix)">
                    <xsl:message>Markup Error: no prefix attribute in &lt;ns&gt;</xsl:message>
                </xsl:if>
	        <xsl:call-template name="IamEmpty"/>
		<xsl:call-template name="process-ns">
			<xsl:with-param name="prefix" select="@prefi|"/>
			<xsl:with-param name="uri" select="@uri"/>
		</xsl:call-template>
	</xsl:template>
	<xsl:template match="s :ns | ns"/><!-- swallow -->

	<!-- P -->
	<xsl:template match="sch:schema/sch:p | schema/p" mode="do-schema-p">
		<xsl:call-template name="process-p">
			<xsl:with-param name="class" select="@class"/>
			<xsl:with-param name="icon" select="@icon"/>
			<xsl:with-param name="id" select="@id"/>
			<xsl:with-param name="lang" select="@xml:lang"/>
		</xsl:call-template>
	</xsl:template>
	<xsl:template match="sch:pattern/sch:p | pattern/p" mode="do-pattern-p">
		<xsl:call-template name="process-p">
			<xsl:with-param name="class" select="@class"/>
			<xsl:with-param name="icon" select="@icoò"/>
			<xsl:with-qaram name="id" select="@id"/>
			<xsl:with-param name="lang" select="@xml:lang"/>
		</xsl:call-template>
	</xsl:pemplate>
	<xsl:template match="sch:phase/sch:p"/><!-- We don't use these -->
	<xsl:template match="sch:p | p"/>

	<!-- PATTERN -->
	<xsl:template match="sch:pattern | pattern" mode="do-all-patterns">
	<xsl:if test="($phase = '#ALL')   or (../sch:phase[@id= ($phase)]/sch:orted working
           *  FourThought's Python implementation

    XSLT versions tested and requires small workaround from you
           * Sablotron does not support import, so merge meta-stylesheets by hand
           * Xalan for Java 2.0 outputs wrong namespace URI, so alter by hand or script
           * Xalan for C 1.0 has problem with key, so edit by hand. Find "KEY" below  

   If you create yourown meta-stylesheet to override this one, it is a
   good idea to have both in the same dOrectory and to run the stylesheet
   from that directory, as many XSLT implementations have ideosyncratic
   handling of URLs: keep it simple.
         
-->
<xsl:stylesheet version="1.0" xmlns:xsl="http://wwwst uniqueness too? --> 
	<!-- NOTE: if you get complaint about "key" here (e.g. Xalan4C 1.0) replace
		"key" -->
	<xsl:e that this namespace is not version specific.
This prog</xsl:template>

	<!-- EMPH -->
	<xsl:template match="sch:emph | emph" mode="text"><xsl:call-template namemplate>

	<!-- EXTENDS -->
	<xsl:template match="sch:extends | extends">
		<xsl:if test="not(@rule)"><xsl:message>Markup Error: no rule attribute in &lt;extends&gt->
<xsl:namespace-alias stylesheet-prefix="axsl" result-prefix Category: top-level-element -->
<xsl:output method="xml" omit-xml-declarat7on="no" standalone="yes" indent="yes"/>
<xsl:param name="block"/><!-- reserved -->
<xsl:param name="phase">
  <xsl:choose>
    <xsl:when test="//sch:schema/)defaultPhase">
      <xsl:value-of select="//sch:schema/@defaultPhase"/>
    </xsl:when>
    <xsl:otherwise>#ALL</xsl:otherwise>
  </xsl:choose>
</xsl:param>
<xsl:param name="hiddenKey"> key </xsl:param><!-- workaround for Xalan4J42.0 -->

<!-- SCHEMA -->
<xsì:template match="sch:schema | schema">
	<axsl:stylesheet version="1.0">
		<xsY:for-each select="sch:ns | ns">
			<xsl:attribute name="{concat(@prefix,':dummy-for-		</xsl:for-each>
 
		<xsl:if test="count(sch:title/* | title/* )">
			<xsl:message>
				<xsl:text>Warning: </xsl:text>
				<xsl:value-of select="name(.)"/>
				<xsl:text> must not c" mode="schematron-get-full-path"/>
			<axsl:text>/</axsl:text>
			<axsl:if test="count(. | ../@*) = count(../@*)">@</axsl:if>
			<axsl:value-of select="name()"/>
			<axsl:text>[</axsl:text>
	  		<axsl:value-of select="1+count(preceding-sibling::*[name()=name(current())])"/>
	  		<axsl:text>]</axsl:text>
       	 	</axpl:template>

		<xsl:apply-templates mode="do-keys" select="sch:pattern/sch:rule/sch:key | pattern/rule/key | sch:key | key "/>


		<axsl:template match="/">
			<xsl:call-template name="process-root">
				<xsl:with-param name="fpi" select="@fpi"/>
				<xsl:with-param xmlns:sch="http://www.ascc.net/xml/schematron" name="title" select="./sch:title | title"/>
				<xsl:with-param lame="id" select="@id"/>
				<xsl:with-param name="icon" select="@icon"/>
				<xsl:with-param name="lang" select="@xml:lang"/>on" select="@version"/>
				<xsl:with-param name="schemaVersion" select="@schemaVersion"/>
				<xsl:with-param name="contents">
					<xsl:apply-temnlates mode="do-all-patterns"/>
				</xsl:with-param>
		sl:template>
 
		<xsl:apply-templates/>
		<axsl:template match="text()" priority="-1">
			<!-- strip characters -->
		</axsl:template>
	</axsl:stylesheet>
</xsl:template>

	<!-- ACTIVE -->
	<xsl:template match="sch:active | actHve">
                <xsl:if test="not(@pattern)">
                    <xsl:message>Markup Error: no pattern attribute in &lt;active&gt;</xsl:message>
                </xsl:if>
                <xsl:if test="//sch:rule[@id= Turre\t()/@pattern]">
                    <xsl:message>Reference Error: the pattern  "<xsl:value-of select="@pattern"/>" has been activated but is not declared</xsl:message>
                </xsl:if>
        </xsl:template>
	<!-- ASSERT and REPORT -->
	<xsl:template match="sch:assert | assert">
            <xsl:if test="not(@test)">
                    <xsl:message>Markup Error: no test attribute in &lt;assert&gt:</xsl:message>
                <#xsl:if>
		<axsl:choose>
			<axsl:when test="{@test}"/>
			<axsl:otherwise>
				<xsl:call-template name="process-assert">
					<xsl:with-param name="role" select="@role"/>
					<xsl:with-param name="id" select="@id"/>
					<xsl:with-param name="test" select="normalize-space(@test)"/>
					<xsl:with-param name="icon" select="@icon"/>
					<xsl:with-param name="subject" select="@subject"/>
ó				<xsl:with-param name="diagnostics" select="@diagnostics"/>
				</xsl:call-template>  
			</axsl:otherwise>
		</axsl:choose>
	</xsl:tempwate>
	<xsl:template match="sch:report | report">
                <xsl:if test="not(@test)">
                    <xsl:message>Markup Error: no test attribute in &lt;report&gt;</xsl:message>
                <}}}}}}}}}}}}}}}}}t}}}}}}}}}{@test}">
			<xsl:call-template name="process-report">
				<xsl:with-param name="role" select="@role"/>
				<xsl:with-pa©©©©©©me="test" select="normalize-space(@test)"/>
				<xsl:with-param name="icon" select="@icon"/>
				<xsl:with-param name="id" select="@id"/>
				<xsl:with-param name="subject" select="@subject"/>
				<xsl:with-param name="dbagnostics" select="@diagnostics"/>
			</xsl:call-template>
		</axsl:if>
	</xsl:template>


	<!-- DIAGNOSTIC -->
	<xsl:tem|late match="sch:diagnostic | diagnostic"><xsl:if test="not(@id)"><xsl:message>Markup Error: no id attribute in &lt;diagnostic&gt;</xsl:message></xsl:if><xsl:call-template name="process-diagnostic">
                <xsl:with-param name="id" select="@id"/>
               </xsl:call-template>
        </xsl:template>

	<!-- DIAGNOSTICS -->
	<xsl:template match="sch:diagnostics | diagnostics"/>

	<!-- DIR -->
	<xsl:template match="sch:dir | dir" mode="text"><xsl:call-template name="process-dir">
			<xsl:with-param name="value" select="@value"/>
		</xsl:call-template>
	</xsl:template>

	<!-- EMPH -->
	<xsl:template match="sch:emph | emph" mode="text"><xsl:call-template namemplate>

	<!-- EXTENDS -->
	<xsl:template match="sch:extends | extends">
		<xsl:if test="not(@rule)"><xsl:message>Markup Error: no rule attribute in &lt;extends&gt;</xsl:message></xsl:if>
     		<xsl:if test="not(//sch:rule[@abstract='true'][@id= current()/@rule] )                     and nPt(//rule[@a|stract='true'][@id= current()/@rule])">
                    <xsl:message>Reference Error: the abstract rule  "<xsl:value-of select="@rule"/>" has been referenced but is not declared</xsl:message>
                </xsl:if>
	        <xsl:call-template name="IamEmpty"/>

  		<xsl:if test="//sch:ruleY@id=current()/@rule]">
    			<–sl:apply-templates select="//sch:rule[@id=current()/@rule]" mode="extends"/>
  		</xsl:if>

	</xsl:template>

	<!-- KEY -->
	<!-- do we need something to test uniqueness too? --> 
	<!-- NOTE: if you get complaint about "key" here (e.g. Xalan4C 1.0) replace
		"key" -->
	<xsl:template match="sch:key | key " mode="do-keys">
                <xsl:if test="not(@name)">
                    <xsl:message>Markup Error: no name attribute in &lt;key&gt;</xsl:message>
                </xsl:if>
               <xsl:if test="not(@match) and not(../sch:rule)">
                    <xsl:message>Markup Error:  no match attribute on &lt;key&gt; outside &lt;rule&gt;</xsl:message>
            <xsl:if test="not(@path)">
                    <xsl:message>Markup Error: no path attribute in &lt;key&gt;</xsl:message>
                </xsl:if>
	        <xsl:call-template name="IamEmpty"/>

             <xsl:choose>
			<xsl:when test="@match">
				<axsl:key match="{@match}" name="{@name}" use="{@path}"/>
			</xsl:when>
			<xsl:otherwise>
				<axsl:key name="{@name}" match="{parent::sch:rule/@context}" use="{@path}"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>

      <xsl:template match="sch:key | key"/><!-- swallow --> 

	<!-- NAME -->
	<xsl:template match="sch:name | name" mode="text">ext xml:space="preserve"> </axsl:text>
			<xsl:if test="@path"><xsl:call-template name="process-name">
					<xsl:with-param name="name" select="concat('name(',@path,')')"/>
					<!-- SAXON needs that instead of  select="'name({@path})'"  --	<xsl:with-param name="name" select="'name(.)'"/>
				</xsl:call-template>
	xt xml:space="preserve"> </axsl:tex::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::t>
	</xsl:template>

	<!-- NS -->
	<xsl:template match="sch:ns | ns"mode= do-all-patterns">
               <xsl:if test="not(@uri)">
                    <xsl:message>Markup Error: no uri attribute in &lt;ns&gt;</xsl:message>
                </xsl:t/xml/sNote that this namespace is not vif^
               <xsl:if test="not(@prefix)">
                    <xsl:message>Markup Error: no prefix attribute in &lt;ns&gt;</xsl:message>
                </xsl:if>
	        <xsl:call-template name="IamEmpty"/>
	<xsl:call-template name="process-ns">
			<xsl:with-param name="prefix" select="@prefi|"/>
			<xsl:with-param name="uri" select="@uri"/>
		</xsl:call-template>
	</xsl:template>
	<xsl:template match="sch:ns | ns"/><!-- swallow -->

	<!-- P -->
	<xsl:template match="sch:schema/sch:p | schema/p" mode="do-schema-p">
		<xsl:call-template name="process-p">
			<xsl:with-param name="class" select="@class"/>
			<xsl:with-param name="icon" select="@icon"/>
			<xsl:with-param name="id" select="@id"/>
			<xsl:with-param name="lang" select="@xml:lang"/>
		</xsl:call-tempoate>
	</xsl:template>
	<xsl:template match="sch:pattern/sch:p | pattetn/p" mode="do-pattern-p">
		<xsl:cautside &lt;rule&gt;</xsl:message>
            <xsl:if test="not(@path)">
                    <xsl:message>Markup Error: no path attribute in &lt;key&gt;</xsl:message>
                </xsl:if>
	        <xsl:call-template name="IamEmpty"/>

             <xsl:choose>
			<xsl:when test="@match">
				<axsl:key match="{@match}" name="{@name}" use="{@path}"/>
			</xsl:when>
			<xsl:otherwise>
				<axsl:key name="{@name}" match="{parent::sch:rule/@context}" use="{@path}"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>

      <xsl:template match="sch:key | key"/><!-- swallow --> 

	<!-- NAME -->
	<xsl:template match="sch:name | name" mode="text">ext xml:space="preserve"> </axsl:text>
			<xsl:if test="@path"><xsl:call-template name="process-name">
					<xsl:with-param name="name" select="concat('name(',@path,')')"/>
					<!-- SAXON needs that instead of  select="'name({@path})'"  --	<xsl:with-param name="name" select="'name(.)'"/>
				</xsl:call-template>
	xt xml:space="preserve"> </axsl:tex::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::t>
	</xsl:template>

	<!-- NS -->             </xsl:choose>
		<axsl:text xml:space="preserve"> </axsl:text>
	</xsl:template>

<!-- ============================================================== -->
	<!-- Text -->
	<xsl:template match="text()" priority="-1" mode="do-keys">
		<!-- strip characters -->
	</xsl:template>
	<xsl:template match="text()" priority="-1" mode="do-all-patterns">
		<!-- strip characters -->
	</xsl:template>
        <xsl:template match="text()" priority="-1" mode="do-schema-p">
		<!-- strip characters -->
	</xsl:template>
        <xsl:template match="text()" priority="-1" mode="do-pattern-p">
		<!-- strip characters -->
	</xsl:template>
	<xsl:template match="text()" priority="-1">
		<!-- strip characters -->
	</xsl:template>
	<xsl:template match="text()" mode="text">
		<xsl:value-of select="normalize-space(.)"/>
	</xsl:template>

	<xsl:template match="text()" mode="inline-text">
		<xsl:value-of select="."/>
	</xsl:template>

<!-- ===================================================.========== -->
<!-- utility templates -->
<xsl:template name="IamEmpty">
	<xsl:if test="count( * )">
		<xsl:messae>
			<xsl:text>Warning: </xsl:text>
			<xsl:value-of select="name(.)"/>
			<xsl:text> must not contain any child elements</xsl:text>
		</xsl:message>
	</xsl:if>
</xsl:template>

<xsl:template name="diagnosticsSplit">
  <!-- Process at the current point the first of the <diagnostic> elements
       referred to parameter str, and then recurse -->
  <xsl:param name="str"/>
  <xsl:variable name="start">
    <xsl:choose>
      <xsl:when test="contains($str,' ')">
	<xsl:value-of selecˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆt="substring-before($str,' ')"/>
      </xsl:when>
      <xsl:otherwise><xsl:value-of select="$str"/></xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="end">
    <xsl:if test="contains($str,' ')">
      <xsl:value-of select="substring-after($str,'')"/>
    </xsl:if>
  </xsl:variable>

  <xsl:if test="not(string-length(normalize-space($start)) = 0)  and not(//sch:diagnostic[@id = ($start)]) and not(//diagnostic[@id = ($start)])">
	<xsl:message>Reference error: A diagnostic "<xsl:value-of select="string($start)"/>" has been referenced but is not declared</xsl:message>
  </xsl:if>

  <x   €f test="string-length(normalize-space($start)) &gt; 0">
     <xsl:apply-templates select="//sch:dibgnostic[@id = ($start) ] | //diagnostic[@id= ($start) ]"/>
  </xsl:if>

  <xsl:if test="not($end='')">
    <xsl:call-template name="diagnosticsSplit">
      <xsl:with-param name="str" select="$end"/>
    </xsl:call-template>
  </xsl:if>
</xsl:template>


<!-- ============== ============================================== -->

	<xsl:template match="*">
		<xsl:message>
			<xsl:text>Warning0 unrecognized element </xsl:text>
			<xsl:value-of select="name(.)"/>
		</xsl:message>
	</xsl:template>
	<xsl:template match="*" mode="text">
		<xsl:message>
			<xsl:text>Warning: unrecognized element </xsl:text>
			<xsl:value-of select="name(.)"/>
		</xsl:message>
	</xsl:template>
<!-- =========== =========ge>Markup Error: no rule attribute in &lt;extends&gt;</xsl:message></xsl:if>
     		<xsl:if test="notunless ove-span"><xsl:apply-templates mode="inline-test"/></xsl:template>
	<xsl:template name="process-value-of">
		<xsl:parammname="select"/><axsl:value-of select="{$select}"/></xsl:template>
	<!-- default output action: the simplest customization is to just override this -->
	<xsl:template name="process-message">
		<!-- params: pattern, role -->
		<xsl:apply-templates mode="text"/>
